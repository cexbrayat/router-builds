{"version":3,"file":"check_guards.js","sourceRoot":"","sources":["../../../../../packages/router/src/operators/check_guards.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '@angular/core';\nimport {MonoTypeOperatorFunction, Observable, from, of } from 'rxjs';\nimport {concatMap, every, first, map, mergeMap} from 'rxjs/operators';\n\nimport {ActivationStart, ChildActivationStart, Event} from '../events';\nimport {NavigationTransition} from '../router';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot} from '../router_state';\nimport {andObservables, wrapIntoObservable} from '../utils/collection';\nimport {CanActivate, CanDeactivate, getCanActivateChild, getToken} from '../utils/preactivation';\n\nexport function checkGuards(moduleInjector: Injector, forwardEvent?: (evt: Event) => void):\n    MonoTypeOperatorFunction<NavigationTransition> {\n  return function(source: Observable<NavigationTransition>) {\n\n    return source.pipe(mergeMap(t => {\n      const {targetSnapshot, currentSnapshot, guards: {canActivateChecks, canDeactivateChecks}} = t;\n      if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {\n        return of ({...t, guardsResult: true});\n      }\n\n      return runCanDeactivateChecks(\n                 canDeactivateChecks, targetSnapshot !, currentSnapshot, moduleInjector)\n          .pipe(\n              mergeMap((canDeactivate: boolean) => {\n                return canDeactivate ?\n                    runCanActivateChecks(\n                        targetSnapshot !, canActivateChecks, moduleInjector, forwardEvent) :\n                    of (false);\n              }),\n              map(guardsResult => ({...t, guardsResult})));\n    }));\n  };\n}\n\nfunction runCanDeactivateChecks(\n    checks: CanDeactivate[], futureRSS: RouterStateSnapshot, currRSS: RouterStateSnapshot,\n    moduleInjector: Injector): Observable<boolean> {\n  return from(checks).pipe(\n      mergeMap(\n          (check: CanDeactivate) =>\n              runCanDeactivate(check.component, check.route, currRSS, futureRSS, moduleInjector)),\n      every((result: boolean) => result === true));\n}\n\nfunction runCanActivateChecks(\n    futureSnapshot: RouterStateSnapshot, checks: CanActivate[], moduleInjector: Injector,\n    forwardEvent?: (evt: Event) => void): Observable<boolean> {\n  return from(checks).pipe(\n      concatMap((check: CanActivate) => andObservables(from([\n                  fireChildActivationStart(check.route.parent, forwardEvent),\n                  fireActivationStart(check.route, forwardEvent),\n                  runCanActivateChild(futureSnapshot, check.path, moduleInjector),\n                  runCanActivate(futureSnapshot, check.route, moduleInjector)\n                ]))),\n      every((result: boolean) => result === true));\n}\n\n/**\n   * This should fire off `ActivationStart` events for each route being activated at this\n   * level.\n   * In other words, if you're activating `a` and `b` below, `path` will contain the\n   * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n   * return\n   * `true` so checks continue to run.\n   */\nfunction fireActivationStart(\n    snapshot: ActivatedRouteSnapshot | null,\n    forwardEvent?: (evt: Event) => void): Observable<boolean> {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ActivationStart(snapshot));\n  }\n  return of (true);\n}\n\n/**\n   * This should fire off `ChildActivationStart` events for each route being activated at this\n   * level.\n   * In other words, if you're activating `a` and `b` below, `path` will contain the\n   * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n   * return\n   * `true` so checks continue to run.\n   */\nfunction fireChildActivationStart(\n    snapshot: ActivatedRouteSnapshot | null,\n    forwardEvent?: (evt: Event) => void): Observable<boolean> {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ChildActivationStart(snapshot));\n  }\n  return of (true);\n}\n\nfunction runCanActivate(\n    futureRSS: RouterStateSnapshot, futureARS: ActivatedRouteSnapshot,\n    moduleInjector: Injector): Observable<boolean> {\n  const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;\n  if (!canActivate || canActivate.length === 0) return of (true);\n  const obs = from(canActivate).pipe(map((c: any) => {\n    const guard = getToken(c, futureARS, moduleInjector);\n    let observable: Observable<boolean>;\n    if (guard.canActivate) {\n      observable = wrapIntoObservable(guard.canActivate(futureARS, futureRSS));\n    } else {\n      observable = wrapIntoObservable(guard(futureARS, futureRSS));\n    }\n    return observable.pipe(first());\n  }));\n  return andObservables(obs);\n}\n\nfunction runCanActivateChild(\n    futureRSS: RouterStateSnapshot, path: ActivatedRouteSnapshot[],\n    moduleInjector: Injector): Observable<boolean> {\n  const futureARS = path[path.length - 1];\n\n  const canActivateChildGuards = path.slice(0, path.length - 1)\n                                     .reverse()\n                                     .map(p => getCanActivateChild(p))\n                                     .filter(_ => _ !== null);\n\n  return andObservables(from(canActivateChildGuards).pipe(map((d: any) => {\n    const obs = from(d.guards).pipe(map((c: any) => {\n      const guard = getToken(c, d.node, moduleInjector);\n      let observable: Observable<boolean>;\n      if (guard.canActivateChild) {\n        observable = wrapIntoObservable(guard.canActivateChild(futureARS, futureRSS));\n      } else {\n        observable = wrapIntoObservable(guard(futureARS, futureRSS));\n      }\n      return observable.pipe(first());\n    }));\n    return andObservables(obs);\n  })));\n}\n\nfunction runCanDeactivate(\n    component: Object | null, currARS: ActivatedRouteSnapshot, currRSS: RouterStateSnapshot,\n    futureRSS: RouterStateSnapshot, moduleInjector: Injector): Observable<boolean> {\n  const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;\n  if (!canDeactivate || canDeactivate.length === 0) return of (true);\n  const canDeactivate$ = from(canDeactivate).pipe(mergeMap((c: any) => {\n    const guard = getToken(c, currARS, moduleInjector);\n    let observable: Observable<boolean>;\n    if (guard.canDeactivate) {\n      observable = wrapIntoObservable(guard.canDeactivate(component, currARS, currRSS, futureRSS));\n    } else {\n      observable = wrapIntoObservable(guard(component, currARS, currRSS, futureRSS));\n    }\n    return observable.pipe(first());\n  }));\n  return canDeactivate$.pipe(every((result: any) => result === true));\n}\n"]}