{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","../../../packages/router/esm5/src/events.js","../../../packages/router/esm5/src/components/empty_outlet.js","../../../packages/router/esm5/src/shared.js","../../../packages/router/esm5/src/config.js","../../../packages/router/esm5/src/utils/collection.js","../../../packages/router/esm5/src/url_tree.js","../../../packages/router/esm5/src/apply_redirects.js","../../../packages/router/esm5/src/utils/tree.js","../../../packages/router/esm5/src/router_state.js","../../../packages/router/esm5/src/create_router_state.js","../../../packages/router/esm5/src/create_url_tree.js","../../../packages/router/esm5/src/pre_activation.js","../../../packages/router/esm5/src/recognize.js","../../../packages/router/esm5/src/route_reuse_strategy.js","../../../packages/router/esm5/src/router_config_loader.js","../../../packages/router/esm5/src/url_handling_strategy.js","../../../packages/router/esm5/src/router.js","../../../packages/router/esm5/src/directives/router_link.js","../../../packages/router/esm5/src/directives/router_link_active.js","../../../packages/router/esm5/src/router_outlet_context.js","../../../packages/router/esm5/src/directives/router_outlet.js","../../../packages/router/esm5/src/router_preloader.js","../../../packages/router/esm5/src/router_scroller.js","../../../packages/router/esm5/src/router_module.js"],"names":["exports","module","factory","require","extendStatics","d","b","__proto__","Array","p","hasOwnProperty","__","this","constructor","Object","create","prototype","assign","t","s","i","n","arguments","length","call","RouterEvent","id","url","navigationTrigger","restoredState","__extends","NavigationStart","_super","toString","NavigationEnd","NavigationCancel","NavigationError","RoutesRecognized","urlAfterRedirects","state","GuardsCheckStart","_this","GuardsCheckEnd","shouldActivate","ResolveStart","ResolveEnd","route","RouteConfigLoadStart","RouteConfigLoadEnd","snapshot","Scroll","anchor","EmptyOutletComponent","name","params","get","has","getAll","v","isArray","defineProperty","ParamsAsMap","keys","NAVIGATION_CANCELING_ERROR","defaultUrlMatcher","segments","segmentGroup","parts","split","hasChildren","part","index","segment","posParams","substring","path","LoadedRouterConfig","routes","validateConfig","config","parentPath","validateNode","fullPath","Error","component","children","loadChildren","outlet","PRIMARY_OUTLET","redirectTo","matcher","charAt","pathMatch","getFullPath","currentRoute","standardizeConfig","r","map","c","__assign","shallowEqual","a","k1","k2","key","forEach","map$$1","callback","prop","_angular_core","ɵisPromise","value","containsTree","container","containee","exact","equalQueryParams","queryParams","equalSegmentGroups","equalPath","numberOfChildren","containeePaths","current","slice","containsSegmentGroup","next","UrlTree","root","fragment","_queryParamMap","convertToParamMap","UrlSegmentGroup","UrlSegment","parameters","_parameterMap","fn","res","child","childOutlet","concat","DefaultUrlSerializer","parse","serialize","serializePaths","primary","serializeSegment","children_1","k","push","join","mapChildrenIntoArray","tree","encodeUriQuery","DEFAULT_SERIALIZER","encodeUriString","encodeURIComponent","SEGMENT_RE","QUERY_PARAM_RE","QUERY_PARAM_VALUE_RE","remaining","parseRootSegment","consumeOptional","peekStartsWith","parseChildren","parseQueryParams","parseFragment","decodeURIComponent","parseSegment","capture","parseParens","matchSegments","decode","parseMatrixParams","valueMatch","str","match","matchUrlQueryParamValue","decodedKey","decodeQuery","currentVal","decodedVal","outletName","indexOf","substr","allowPrimary","startsWith","NoMatch","AbsoluteRedirect","message","ApplyRedirects","moduleInjector","configLoader","urlSerializer","urlTree","ngModule","NgModuleRef","pipe","rxjs_operators","rootSegmentGroup","createUrlTree","e","allowRedirects","catchError","noMatchError","rootCandidate","_a","obj","rxjs","of","waitHead","waitTail","mapped","expandSegmentAgainstRoute","concatAll","first","_","EmptyError","noLeftoversInUrl","paths","getOutlet","noMatch","undefined","matchSegmentAgainstRoute","absoluteRedirect","newTree","lineralizeSegments","mergeMap","newSegments","matched","consumedSegments","lastChild","positionalParamSegments","applyRedirectCommands","rawSegmentGroup","load","injector","cfg","_loadedConfig","rawSlicedSegments","getChildConfig","routerConfig","childConfig","slicedSegments","containsEmptyPathRedirectsWithNamedOutlets","primarySegmentGroup","_i","routes_2","mergeTrivialChildren","containsEmptyPathRedirects","routes_1","tslib_1.__assign","isEmptyPathRedirect","expandChildren","childModule","expandSegment","canLoad","from","injectionToken","shouldLoad","createQueryParams","redirectToParams","actualParams","sourceName","group","updatedSegments","createSegments","redirectToUrlSegment","findOrReturn","actualSegments","actualSegments_1","splice","idx","Tree","parent","firstChild","siblings","findPath","_root","pathFromRoot","node","node_1","findNode","unshift","TreeNode","nodeChildrenAsMap","RouterState","emptyQueryParams","BehaviorSubject","ActivatedRoute","data","futureSnapshot","enumerable","_routerState","_paramMap","configurable","inheritedParamsDataResolve","paramsInheritanceStrategy","inheritingStartingFrom","parent_1","routeConfig","curr","ActivatedRouteSnapshot","urlSegment","lastPathIndex","resolve","_lastPathIndex","RouterStateSnapshot","advanceActivatedRoute","currentSnapshot","nextSnapshot","_futureSnapshot","shallowEqualArrays","equalParamsAndUrlSegments","equalUrlParams","createNode","routeReuseStrategy","prevState","shouldReuseRoute","detachedRouteHandle","retrieve","setFutureSnapshotsOfActivatedRoutes","result","commands","nav","Navigation","numberOfDoubleDots","reduce","cmd","cmdIdx","outlets","outlets_1","segmentPath","partIndex","urlPart","isAbsolute","computeNavigation","startingPosition","Position","_urlSegment","g","ci","dd","findStartingPosition","oldSegmentGroup","newSegmentGroup","qp","oldSegment","newSegment","replaceSegment","last","toRoot","processChildren","getPath","command","updateSegmentGroup","startIndex","updateSegmentGroupChildren","m","currentCommandIndex","pathIndex","commandIndex","currentPathIndex","compare","prefixedWith","slicedCommands","createNewSegmentGroup","_b","getOutlets","outlets_2","isMatrixParams","stringify","CanActivate","CanDeactivate","PreActivation","future","forwardEvent","parentContexts","setupChildRouteGuards","futureRoot","currRoot","checkGuards","isDeactivating","resolveData","concatMap","check","runResolve","futureNode","currNode","contexts","futurePath","prevChildren","setupRouteGuards","context","getContext","shouldRunGuardsAndResolvers","canActivateChecks","canDeactivateChecks","deactivateRouteAndItsChildren","mode","childName","isActivated","runCanDeactivateChecks","runCanDeactivate","every","runCanActivateChecks","fireChildActivationStart","runCanActivate","canActivate","guard","getToken","wrapIntoObservable","runCanActivateChild","reverse","guards","canActivateChild","canDeactivate","_resolve","resolveNode","resolvedData","key_1","getResolver","token","closestLoadedConfig","Recognizer","rootComponentType","relativeLinkResolution","freeze","rootNode","routeState","Observable","inheritParamsAndData","routeNode","routeWithSameOutletName","names","nodes","sort","config_1","processSegmentAgainstRoute","NoMatch$1","last$1","getData","getSourceSegmentGroup","rawSegment","getPathIndexShift","getResolve","split$1","_segmentIndexShift","_sourceSegment","containsEmptyPathMatchesWithNamedOutlets","s_1","primarySegment","getOutlet$1","createChildrenForEmptyPaths","containsEmptyPathMatches","s_2","emptyPathMatch","DefaultRouteReuseStrategy","store","detachedTree","InjectionToken","RouterConfigLoader","loader","compiler","onLoadStartListener","onLoadEndListener","loadModuleFactory","NgModuleFactory","compileModuleAsync","DefaultUrlHandlingStrategy","merge","Router","rootContexts","location","Subject","malformedUriErrorHandler","defaultMalformedUriErrorHandler","afterPreactivation","defaultRouterHook","resetConfig","currentUrlTree","triggerEvent","initialNavigation","setUpLocationChangeListener","locationSubscription","rawUrlTree","parseUrl","change","source","navigationId","dispose","navigationExtras","relativeTo","preserveQueryParams","queryParamsHandling","preserveFragment","console","warn","routerState","q","extras","skipLocationChange","serializeUrl","removeEmptyProps","processNavigations","executeScheduledNavigation","promise","catch","lastNavigation","navigations","Promise","reject","rej","rawUrl","urlHandlingStrategy","extract","navigated","onSameUrlNavigation","urlTransition","shouldProcessUrl","urlUpdateStrategy","setBrowserUrl","replaceUrl","then","runNavigate","createEmptyState","precreatedState","resolvePromise","rejectPromise","urlAndSnapshot$","appliedUrl","apply","applyRedirects","recognize","preActivation","hooks","beforePreactivation","evt","initialize","isActivating","storedState","storedUrl","ActivateRoutes","activate","navigationIsSuccessful","lastSuccessfulId","resetUrlToCurrentUrlTree","resetStateAndUrl","errorHandler","ee","isCurrentPathEqualTo","replaceState","futureState","currState","futureChild","childOutletName","deactivateRoutes","parentContext","deactivateChildRoutes","shouldDetach","detachAndStoreRouteSubtree","componentRef","detach","deactivateRouteAndOutlet","contexts_1","deactivate","activateRoutes","ActivationEnd","getOrCreateContext","activateChildRoutes","shouldAttach","stored","attachRef","parentLoadedConfig","resolver","cmpFactoryResolver","activateWith","RouterLink","router","tabIndex","renderer","el","set","isDevMode","onClick","attrBoolValue","preserve","decorators","type","Directive","args","selector","ctorParameters","ElementRef","String","Input","Attribute","propDecorators","HostListener","routerLink","RouterLinkWithHref","locationStrategy","subscription","events","subscribe","updateTargetUrlAndHref","button","ctrlKey","metaKey","shiftKey","target","_angular_common","HostBinding","href","RouterLinkActive","element","cdr","isActive","routerLinkActiveOptions","ngAfterContentInit","links","changes","update","classes","linksWithHrefs","hasActiveLinks","addClass","nativeElement","removeClass","isLinkActive","some","exportAs","ContentChildren","Renderer2","ChangeDetectorRef","descendants","ChildrenOutletContexts","onOutletDeactivated","RouterOutlet","changeDetector","activated","_activatedRoute","onChildOutletCreated","attach","instance","insert","ref","hostView","destroy","activatedRoute","resolveComponentFactory","OutletInjector","childContexts","createComponent","markForCheck","ViewContainerRef","ComponentFactoryResolver","Output","activateEvents","deactivateEvents","notFoundValue","PreloadAllModules","preload","NoPreloading","RouterPreloader","moduleLoader","preloadingStrategy","setUpPreloading","processRoutes","preloadConfig","Injectable","NgModuleFactoryLoader","Compiler","RouterScroller","viewportScroller","options","lastId","lastSource","restoredId","anchorScrolling","scrollPositionRestoration","scrollEventsSubscription","consumeScrollEvents","createScrollEvents","getScrollPosition","scrollToPosition","position","scrollToAnchor","scheduleScrollEvent","routerEvent","ngOnDestroy","routerEventsSubscription","unsubscribe","ROUTER_FORROOT_GUARD","Location","ApplicationRef","setupRouter","deps","UrlSerializer","Injector","ROUTES","ROUTER_CONFIGURATION","UrlHandlingStrategy","Optional","SystemJsNgModuleLoader","provide","useFactory","rootRoute","useClass","useValue","enableTracing","RouterModule","LocationStrategy","SkipSelf","PlatformLocation","provideLocationStrategy","Inject","APP_BASE_HREF","createRouterScroller","ViewportScroller","PreloadingStrategy","useExisting","forChild","providers","provideRoutes","NgModule","ROUTER_DIRECTIVES","entryComponents","provideForRootGuard","opts","flatten","dom_1","_angular_platformBrowser","ɵgetDOM","logGroup","log","logGroupEnd","resultOfPreactivationDone","LOCATION_INITIALIZED","isLegacyDisabled","isLegacyEnabled","initNavigation","routerScroller","bootstrappedComponentRef","components","preloader","ROUTER_INITIALIZER","APP_INITIALIZER","multi","APP_BOOTSTRAP_LISTENER","getAppInitializer","RouterInitializer"],"mappings":"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","file":"/Users/ced-pro/Code/angular/angular/dist/packages-dist/router/bundles/router.umd.min.js.map","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as tslib_1 from \"tslib\";\n/** @typedef {?} */\nvar NavigationTrigger;\nexport { NavigationTrigger };\n/**\n * \\@description\n *\n * Base for events the Router goes through, as opposed to events tied to a specific\n * Route. `RouterEvent`s will only be fired one time for any given navigation.\n *\n * Example:\n *\n * ```\n * class MyService {\n *   constructor(public router: Router, logger: Logger) {\n *     router.events.filter(e => e instanceof RouterEvent).subscribe(e => {\n *       logger.log(e.id, e.url);\n *     });\n *   }\n * }\n * ```\n *\n * \\@experimental\n */\nvar /**\n * \\@description\n *\n * Base for events the Router goes through, as opposed to events tied to a specific\n * Route. `RouterEvent`s will only be fired one time for any given navigation.\n *\n * Example:\n *\n * ```\n * class MyService {\n *   constructor(public router: Router, logger: Logger) {\n *     router.events.filter(e => e instanceof RouterEvent).subscribe(e => {\n *       logger.log(e.id, e.url);\n *     });\n *   }\n * }\n * ```\n *\n * \\@experimental\n */\nRouterEvent = /** @class */ (function () {\n    function RouterEvent(id, url) {\n        this.id = id;\n        this.url = url;\n    }\n    return RouterEvent;\n}());\n/**\n * \\@description\n *\n * Base for events the Router goes through, as opposed to events tied to a specific\n * Route. `RouterEvent`s will only be fired one time for any given navigation.\n *\n * Example:\n *\n * ```\n * class MyService {\n *   constructor(public router: Router, logger: Logger) {\n *     router.events.filter(e => e instanceof RouterEvent).subscribe(e => {\n *       logger.log(e.id, e.url);\n *     });\n *   }\n * }\n * ```\n *\n * \\@experimental\n */\nexport { RouterEvent };\nif (false) {\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    RouterEvent.prototype.id;\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    RouterEvent.prototype.url;\n}\n/**\n * \\@description\n *\n * Represents an event triggered when a navigation starts.\n *\n *\n */\nvar /**\n * \\@description\n *\n * Represents an event triggered when a navigation starts.\n *\n *\n */\nNavigationStart = /** @class */ (function (_super) {\n    tslib_1.__extends(NavigationStart, _super);\n    function NavigationStart(/** @docsNotRequired */\n    /** @docsNotRequired */\n    id, /** @docsNotRequired */\n    /** @docsNotRequired */\n    url, /** @docsNotRequired */\n    /** @docsNotRequired */\n    navigationTrigger, /** @docsNotRequired */\n    /** @docsNotRequired */\n    restoredState) {\n        if (navigationTrigger === void 0) { \n        /** @docsNotRequired */\n        navigationTrigger = 'imperative'; }\n        if (restoredState === void 0) { \n        /** @docsNotRequired */\n        restoredState = null; }\n        var _this = _super.call(this, id, url) || this;\n        _this.navigationTrigger = navigationTrigger;\n        _this.restoredState = restoredState;\n        return _this;\n    }\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    NavigationStart.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () { return \"NavigationStart(id: \" + this.id + \", url: '\" + this.url + \"')\"; };\n    return NavigationStart;\n}(RouterEvent));\n/**\n * \\@description\n *\n * Represents an event triggered when a navigation starts.\n *\n *\n */\nexport { NavigationStart };\nif (false) {\n    /**\n     * Identifies the trigger of the navigation.\n     *\n     * * 'imperative'--triggered by `router.navigateByUrl` or `router.navigate`.\n     * * 'popstate'--triggered by a popstate event\n     * * 'hashchange'--triggered by a hashchange event\n     * @type {?}\n     */\n    NavigationStart.prototype.navigationTrigger;\n    /**\n     * This contains the navigation id that pushed the history record that the router navigates\n     * back to. This is not null only when the navigation is triggered by a popstate event.\n     *\n     * The router assigns a navigationId to every router transition/navigation. Even when the user\n     * clicks on the back button in the browser, a new navigation id will be created. So from\n     * the perspective of the router, the router never \"goes back\". By using the `restoredState`\n     * and its navigationId, you can implement behavior that differentiates between creating new\n     * states\n     * and popstate events. In the latter case you can restore some remembered state (e.g., scroll\n     * position).\n     * @type {?}\n     */\n    NavigationStart.prototype.restoredState;\n}\n/**\n * \\@description\n *\n * Represents an event triggered when a navigation ends successfully.\n *\n *\n */\nvar /**\n * \\@description\n *\n * Represents an event triggered when a navigation ends successfully.\n *\n *\n */\nNavigationEnd = /** @class */ (function (_super) {\n    tslib_1.__extends(NavigationEnd, _super);\n    function NavigationEnd(/** @docsNotRequired */\n    /** @docsNotRequired */\n    id, /** @docsNotRequired */\n    /** @docsNotRequired */\n    url, urlAfterRedirects) {\n        var _this = _super.call(this, id, url) || this;\n        _this.urlAfterRedirects = urlAfterRedirects;\n        return _this;\n    }\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    NavigationEnd.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () {\n        return \"NavigationEnd(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"')\";\n    };\n    return NavigationEnd;\n}(RouterEvent));\n/**\n * \\@description\n *\n * Represents an event triggered when a navigation ends successfully.\n *\n *\n */\nexport { NavigationEnd };\nif (false) {\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    NavigationEnd.prototype.urlAfterRedirects;\n}\n/**\n * \\@description\n *\n * Represents an event triggered when a navigation is canceled.\n *\n *\n */\nvar /**\n * \\@description\n *\n * Represents an event triggered when a navigation is canceled.\n *\n *\n */\nNavigationCancel = /** @class */ (function (_super) {\n    tslib_1.__extends(NavigationCancel, _super);\n    function NavigationCancel(/** @docsNotRequired */\n    /** @docsNotRequired */\n    id, /** @docsNotRequired */\n    /** @docsNotRequired */\n    url, reason) {\n        var _this = _super.call(this, id, url) || this;\n        _this.reason = reason;\n        return _this;\n    }\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    NavigationCancel.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () { return \"NavigationCancel(id: \" + this.id + \", url: '\" + this.url + \"')\"; };\n    return NavigationCancel;\n}(RouterEvent));\n/**\n * \\@description\n *\n * Represents an event triggered when a navigation is canceled.\n *\n *\n */\nexport { NavigationCancel };\nif (false) {\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    NavigationCancel.prototype.reason;\n}\n/**\n * \\@description\n *\n * Represents an event triggered when a navigation fails due to an unexpected error.\n *\n *\n */\nvar /**\n * \\@description\n *\n * Represents an event triggered when a navigation fails due to an unexpected error.\n *\n *\n */\nNavigationError = /** @class */ (function (_super) {\n    tslib_1.__extends(NavigationError, _super);\n    function NavigationError(/** @docsNotRequired */\n    /** @docsNotRequired */\n    id, /** @docsNotRequired */\n    /** @docsNotRequired */\n    url, error) {\n        var _this = _super.call(this, id, url) || this;\n        _this.error = error;\n        return _this;\n    }\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    NavigationError.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () {\n        return \"NavigationError(id: \" + this.id + \", url: '\" + this.url + \"', error: \" + this.error + \")\";\n    };\n    return NavigationError;\n}(RouterEvent));\n/**\n * \\@description\n *\n * Represents an event triggered when a navigation fails due to an unexpected error.\n *\n *\n */\nexport { NavigationError };\nif (false) {\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    NavigationError.prototype.error;\n}\n/**\n * \\@description\n *\n * Represents an event triggered when routes are recognized.\n *\n *\n */\nvar /**\n * \\@description\n *\n * Represents an event triggered when routes are recognized.\n *\n *\n */\nRoutesRecognized = /** @class */ (function (_super) {\n    tslib_1.__extends(RoutesRecognized, _super);\n    function RoutesRecognized(/** @docsNotRequired */\n    /** @docsNotRequired */\n    id, /** @docsNotRequired */\n    /** @docsNotRequired */\n    url, urlAfterRedirects, state) {\n        var _this = _super.call(this, id, url) || this;\n        _this.urlAfterRedirects = urlAfterRedirects;\n        _this.state = state;\n        return _this;\n    }\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    RoutesRecognized.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () {\n        return \"RoutesRecognized(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \")\";\n    };\n    return RoutesRecognized;\n}(RouterEvent));\n/**\n * \\@description\n *\n * Represents an event triggered when routes are recognized.\n *\n *\n */\nexport { RoutesRecognized };\nif (false) {\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    RoutesRecognized.prototype.urlAfterRedirects;\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    RoutesRecognized.prototype.state;\n}\n/**\n * \\@description\n *\n * Represents the start of the Guard phase of routing.\n *\n * \\@experimental\n */\nvar /**\n * \\@description\n *\n * Represents the start of the Guard phase of routing.\n *\n * \\@experimental\n */\nGuardsCheckStart = /** @class */ (function (_super) {\n    tslib_1.__extends(GuardsCheckStart, _super);\n    function GuardsCheckStart(/** @docsNotRequired */\n    /** @docsNotRequired */\n    id, /** @docsNotRequired */\n    /** @docsNotRequired */\n    url, urlAfterRedirects, state) {\n        var _this = _super.call(this, id, url) || this;\n        _this.urlAfterRedirects = urlAfterRedirects;\n        _this.state = state;\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    GuardsCheckStart.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        return \"GuardsCheckStart(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \")\";\n    };\n    return GuardsCheckStart;\n}(RouterEvent));\n/**\n * \\@description\n *\n * Represents the start of the Guard phase of routing.\n *\n * \\@experimental\n */\nexport { GuardsCheckStart };\nif (false) {\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    GuardsCheckStart.prototype.urlAfterRedirects;\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    GuardsCheckStart.prototype.state;\n}\n/**\n * \\@description\n *\n * Represents the end of the Guard phase of routing.\n *\n * \\@experimental\n */\nvar /**\n * \\@description\n *\n * Represents the end of the Guard phase of routing.\n *\n * \\@experimental\n */\nGuardsCheckEnd = /** @class */ (function (_super) {\n    tslib_1.__extends(GuardsCheckEnd, _super);\n    function GuardsCheckEnd(/** @docsNotRequired */\n    /** @docsNotRequired */\n    id, /** @docsNotRequired */\n    /** @docsNotRequired */\n    url, urlAfterRedirects, state, shouldActivate) {\n        var _this = _super.call(this, id, url) || this;\n        _this.urlAfterRedirects = urlAfterRedirects;\n        _this.state = state;\n        _this.shouldActivate = shouldActivate;\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    GuardsCheckEnd.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        return \"GuardsCheckEnd(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \", shouldActivate: \" + this.shouldActivate + \")\";\n    };\n    return GuardsCheckEnd;\n}(RouterEvent));\n/**\n * \\@description\n *\n * Represents the end of the Guard phase of routing.\n *\n * \\@experimental\n */\nexport { GuardsCheckEnd };\nif (false) {\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    GuardsCheckEnd.prototype.urlAfterRedirects;\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    GuardsCheckEnd.prototype.state;\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    GuardsCheckEnd.prototype.shouldActivate;\n}\n/**\n * \\@description\n *\n * Represents the start of the Resolve phase of routing. The timing of this\n * event may change, thus it's experimental. In the current iteration it will run\n * in the \"resolve\" phase whether there's things to resolve or not. In the future this\n * behavior may change to only run when there are things to be resolved.\n *\n * \\@experimental\n */\nvar /**\n * \\@description\n *\n * Represents the start of the Resolve phase of routing. The timing of this\n * event may change, thus it's experimental. In the current iteration it will run\n * in the \"resolve\" phase whether there's things to resolve or not. In the future this\n * behavior may change to only run when there are things to be resolved.\n *\n * \\@experimental\n */\nResolveStart = /** @class */ (function (_super) {\n    tslib_1.__extends(ResolveStart, _super);\n    function ResolveStart(/** @docsNotRequired */\n    /** @docsNotRequired */\n    id, /** @docsNotRequired */\n    /** @docsNotRequired */\n    url, urlAfterRedirects, state) {\n        var _this = _super.call(this, id, url) || this;\n        _this.urlAfterRedirects = urlAfterRedirects;\n        _this.state = state;\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    ResolveStart.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        return \"ResolveStart(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \")\";\n    };\n    return ResolveStart;\n}(RouterEvent));\n/**\n * \\@description\n *\n * Represents the start of the Resolve phase of routing. The timing of this\n * event may change, thus it's experimental. In the current iteration it will run\n * in the \"resolve\" phase whether there's things to resolve or not. In the future this\n * behavior may change to only run when there are things to be resolved.\n *\n * \\@experimental\n */\nexport { ResolveStart };\nif (false) {\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    ResolveStart.prototype.urlAfterRedirects;\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    ResolveStart.prototype.state;\n}\n/**\n * \\@description\n *\n * Represents the end of the Resolve phase of routing. See note on\n * `ResolveStart` for use of this experimental API.\n *\n * \\@experimental\n */\nvar /**\n * \\@description\n *\n * Represents the end of the Resolve phase of routing. See note on\n * `ResolveStart` for use of this experimental API.\n *\n * \\@experimental\n */\nResolveEnd = /** @class */ (function (_super) {\n    tslib_1.__extends(ResolveEnd, _super);\n    function ResolveEnd(/** @docsNotRequired */\n    /** @docsNotRequired */\n    id, /** @docsNotRequired */\n    /** @docsNotRequired */\n    url, urlAfterRedirects, state) {\n        var _this = _super.call(this, id, url) || this;\n        _this.urlAfterRedirects = urlAfterRedirects;\n        _this.state = state;\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    ResolveEnd.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        return \"ResolveEnd(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \")\";\n    };\n    return ResolveEnd;\n}(RouterEvent));\n/**\n * \\@description\n *\n * Represents the end of the Resolve phase of routing. See note on\n * `ResolveStart` for use of this experimental API.\n *\n * \\@experimental\n */\nexport { ResolveEnd };\nif (false) {\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    ResolveEnd.prototype.urlAfterRedirects;\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    ResolveEnd.prototype.state;\n}\n/**\n * \\@description\n *\n * Represents an event triggered before lazy loading a route config.\n *\n * \\@experimental\n */\nvar /**\n * \\@description\n *\n * Represents an event triggered before lazy loading a route config.\n *\n * \\@experimental\n */\nRouteConfigLoadStart = /** @class */ (function () {\n    function RouteConfigLoadStart(route) {\n        this.route = route;\n    }\n    /**\n     * @return {?}\n     */\n    RouteConfigLoadStart.prototype.toString = /**\n     * @return {?}\n     */\n    function () { return \"RouteConfigLoadStart(path: \" + this.route.path + \")\"; };\n    return RouteConfigLoadStart;\n}());\n/**\n * \\@description\n *\n * Represents an event triggered before lazy loading a route config.\n *\n * \\@experimental\n */\nexport { RouteConfigLoadStart };\nif (false) {\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    RouteConfigLoadStart.prototype.route;\n}\n/**\n * \\@description\n *\n * Represents an event triggered when a route has been lazy loaded.\n *\n * \\@experimental\n */\nvar /**\n * \\@description\n *\n * Represents an event triggered when a route has been lazy loaded.\n *\n * \\@experimental\n */\nRouteConfigLoadEnd = /** @class */ (function () {\n    function RouteConfigLoadEnd(route) {\n        this.route = route;\n    }\n    /**\n     * @return {?}\n     */\n    RouteConfigLoadEnd.prototype.toString = /**\n     * @return {?}\n     */\n    function () { return \"RouteConfigLoadEnd(path: \" + this.route.path + \")\"; };\n    return RouteConfigLoadEnd;\n}());\n/**\n * \\@description\n *\n * Represents an event triggered when a route has been lazy loaded.\n *\n * \\@experimental\n */\nexport { RouteConfigLoadEnd };\nif (false) {\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    RouteConfigLoadEnd.prototype.route;\n}\n/**\n * \\@description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ChildActivationEnd` for use of this experimental API.\n *\n * \\@experimental\n */\nvar /**\n * \\@description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ChildActivationEnd` for use of this experimental API.\n *\n * \\@experimental\n */\nChildActivationStart = /** @class */ (function () {\n    function ChildActivationStart(snapshot) {\n        this.snapshot = snapshot;\n    }\n    /**\n     * @return {?}\n     */\n    ChildActivationStart.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n        return \"ChildActivationStart(path: '\" + path + \"')\";\n    };\n    return ChildActivationStart;\n}());\n/**\n * \\@description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ChildActivationEnd` for use of this experimental API.\n *\n * \\@experimental\n */\nexport { ChildActivationStart };\nif (false) {\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    ChildActivationStart.prototype.snapshot;\n}\n/**\n * \\@description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ChildActivationStart` for use of this experimental API.\n *\n * \\@experimental\n */\nvar /**\n * \\@description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ChildActivationStart` for use of this experimental API.\n *\n * \\@experimental\n */\nChildActivationEnd = /** @class */ (function () {\n    function ChildActivationEnd(snapshot) {\n        this.snapshot = snapshot;\n    }\n    /**\n     * @return {?}\n     */\n    ChildActivationEnd.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n        return \"ChildActivationEnd(path: '\" + path + \"')\";\n    };\n    return ChildActivationEnd;\n}());\n/**\n * \\@description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ChildActivationStart` for use of this experimental API.\n *\n * \\@experimental\n */\nexport { ChildActivationEnd };\nif (false) {\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    ChildActivationEnd.prototype.snapshot;\n}\n/**\n * \\@description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ActivationEnd` for use of this experimental API.\n *\n * \\@experimental\n */\nvar /**\n * \\@description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ActivationEnd` for use of this experimental API.\n *\n * \\@experimental\n */\nActivationStart = /** @class */ (function () {\n    function ActivationStart(snapshot) {\n        this.snapshot = snapshot;\n    }\n    /**\n     * @return {?}\n     */\n    ActivationStart.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n        return \"ActivationStart(path: '\" + path + \"')\";\n    };\n    return ActivationStart;\n}());\n/**\n * \\@description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ActivationEnd` for use of this experimental API.\n *\n * \\@experimental\n */\nexport { ActivationStart };\nif (false) {\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    ActivationStart.prototype.snapshot;\n}\n/**\n * \\@description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ActivationStart` for use of this experimental API.\n *\n * \\@experimental\n */\nvar /**\n * \\@description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ActivationStart` for use of this experimental API.\n *\n * \\@experimental\n */\nActivationEnd = /** @class */ (function () {\n    function ActivationEnd(snapshot) {\n        this.snapshot = snapshot;\n    }\n    /**\n     * @return {?}\n     */\n    ActivationEnd.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n        return \"ActivationEnd(path: '\" + path + \"')\";\n    };\n    return ActivationEnd;\n}());\n/**\n * \\@description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ActivationStart` for use of this experimental API.\n *\n * \\@experimental\n */\nexport { ActivationEnd };\nif (false) {\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    ActivationEnd.prototype.snapshot;\n}\n/**\n * \\@description\n *\n * Represents a scrolling event.\n */\nvar /**\n * \\@description\n *\n * Represents a scrolling event.\n */\nScroll = /** @class */ (function () {\n    function Scroll(/** @docsNotRequired */\n    routerEvent, /** @docsNotRequired */\n    position, /** @docsNotRequired */\n    anchor) {\n        this.routerEvent = routerEvent;\n        this.position = position;\n        this.anchor = anchor;\n    }\n    /**\n     * @return {?}\n     */\n    Scroll.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var pos = this.position ? this.position[0] + \", \" + this.position[1] : null;\n        return \"Scroll(anchor: '\" + this.anchor + \"', position: '\" + pos + \"')\";\n    };\n    return Scroll;\n}());\n/**\n * \\@description\n *\n * Represents a scrolling event.\n */\nexport { Scroll };\nif (false) {\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    Scroll.prototype.routerEvent;\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    Scroll.prototype.position;\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    Scroll.prototype.anchor;\n}\n/** @typedef {?} */\nvar Event;\nexport { Event };\n//# sourceMappingURL=events.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Component } from '@angular/core';\n/**\n * This component is used internally within the router to be a placeholder when an empty\n * router-outlet is needed. For example, with a config such as:\n *\n * `{path: 'parent', outlet: 'nav', children: [...]}`\n *\n * In order to render, there needs to be a component on this config, which will default\n * to this `EmptyOutletComponent`.\n */\nvar EmptyOutletComponent = /** @class */ (function () {\n    function EmptyOutletComponent() {\n    }\n    EmptyOutletComponent.decorators = [\n        { type: Component, args: [{ template: \"<router-outlet></router-outlet>\" },] },\n    ];\n    return EmptyOutletComponent;\n}());\nexport { EmptyOutletComponent };\n//# sourceMappingURL=empty_outlet.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** *\n * \\@description\n *\n * Name of the primary outlet.\n *\n *\n  @type {?} */\nexport var PRIMARY_OUTLET = 'primary';\n/** @typedef {?} */\nvar Params;\nexport { Params };\n/**\n * Matrix and Query parameters.\n *\n * `ParamMap` makes it easier to work with parameters as they could have either a single value or\n * multiple value. Because this should be known by the user, calling `get` or `getAll` returns the\n * correct type (either `string` or `string[]`).\n *\n * The API is inspired by the URLSearchParams interface.\n * see https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\n *\n *\n * @record\n */\nexport function ParamMap() { }\n/** @type {?} */\nParamMap.prototype.has;\n/**\n * Return a single value for the given parameter name:\n * - the value when the parameter has a single value,\n * - the first value if the parameter has multiple values,\n * - `null` when there is no such parameter.\n * @type {?}\n */\nParamMap.prototype.get;\n/**\n * Return an array of values for the given parameter name.\n *\n * If there is no such parameter, an empty array is returned.\n * @type {?}\n */\nParamMap.prototype.getAll;\n/**\n * Name of the parameters\n * @type {?}\n */\nParamMap.prototype.keys;\nvar ParamsAsMap = /** @class */ (function () {\n    function ParamsAsMap(params) {\n        this.params = params || {};\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    ParamsAsMap.prototype.has = /**\n     * @param {?} name\n     * @return {?}\n     */\n    function (name) { return this.params.hasOwnProperty(name); };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    ParamsAsMap.prototype.get = /**\n     * @param {?} name\n     * @return {?}\n     */\n    function (name) {\n        if (this.has(name)) {\n            /** @type {?} */\n            var v = this.params[name];\n            return Array.isArray(v) ? v[0] : v;\n        }\n        return null;\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    ParamsAsMap.prototype.getAll = /**\n     * @param {?} name\n     * @return {?}\n     */\n    function (name) {\n        if (this.has(name)) {\n            /** @type {?} */\n            var v = this.params[name];\n            return Array.isArray(v) ? v : [v];\n        }\n        return [];\n    };\n    Object.defineProperty(ParamsAsMap.prototype, \"keys\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return Object.keys(this.params); },\n        enumerable: true,\n        configurable: true\n    });\n    return ParamsAsMap;\n}());\nif (false) {\n    /** @type {?} */\n    ParamsAsMap.prototype.params;\n}\n/**\n * Convert a `Params` instance to a `ParamMap`.\n *\n *\n * @param {?} params\n * @return {?}\n */\nexport function convertToParamMap(params) {\n    return new ParamsAsMap(params);\n}\n/** @type {?} */\nvar NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\n/**\n * @param {?} message\n * @return {?}\n */\nexport function navigationCancelingError(message) {\n    /** @type {?} */\n    var error = Error('NavigationCancelingError: ' + message);\n    (/** @type {?} */ (error))[NAVIGATION_CANCELING_ERROR] = true;\n    return error;\n}\n/**\n * @param {?} error\n * @return {?}\n */\nexport function isNavigationCancelingError(error) {\n    return error && (/** @type {?} */ (error))[NAVIGATION_CANCELING_ERROR];\n}\n/**\n * @param {?} segments\n * @param {?} segmentGroup\n * @param {?} route\n * @return {?}\n */\nexport function defaultUrlMatcher(segments, segmentGroup, route) {\n    /** @type {?} */\n    var parts = /** @type {?} */ ((route.path)).split('/');\n    if (parts.length > segments.length) {\n        // The actual URL is shorter than the config, no match\n        return null;\n    }\n    if (route.pathMatch === 'full' &&\n        (segmentGroup.hasChildren() || parts.length < segments.length)) {\n        // The config is longer than the actual URL but we are looking for a full match, return null\n        return null;\n    }\n    /** @type {?} */\n    var posParams = {};\n    // Check each config part against the actual URL\n    for (var index = 0; index < parts.length; index++) {\n        /** @type {?} */\n        var part = parts[index];\n        /** @type {?} */\n        var segment = segments[index];\n        /** @type {?} */\n        var isParameter = part.startsWith(':');\n        if (isParameter) {\n            posParams[part.substring(1)] = segment;\n        }\n        else if (part !== segment.path) {\n            // The actual URL part does not match the config, no match\n            return null;\n        }\n    }\n    return { consumed: segments.slice(0, parts.length), posParams: posParams };\n}\n//# sourceMappingURL=shared.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as tslib_1 from \"tslib\";\nimport { EmptyOutletComponent } from './components/empty_outlet';\nimport { PRIMARY_OUTLET } from './shared';\n/** @typedef {?} */\nvar Routes;\nexport { Routes };\n/** @typedef {?} */\nvar UrlMatchResult;\nexport { UrlMatchResult };\n/** @typedef {?} */\nvar UrlMatcher;\nexport { UrlMatcher };\n/** @typedef {?} */\nvar Data;\nexport { Data };\n/** @typedef {?} */\nvar ResolveData;\nexport { ResolveData };\n/** @typedef {?} */\nvar LoadChildrenCallback;\nexport { LoadChildrenCallback };\n/** @typedef {?} */\nvar LoadChildren;\nexport { LoadChildren };\n/** @typedef {?} */\nvar QueryParamsHandling;\nexport { QueryParamsHandling };\n/** @typedef {?} */\nvar RunGuardsAndResolvers;\nexport { RunGuardsAndResolvers };\n/**\n * See `Routes` for more details.\n *\n * @record\n */\nexport function Route() { }\n/** @type {?|undefined} */\nRoute.prototype.path;\n/** @type {?|undefined} */\nRoute.prototype.pathMatch;\n/** @type {?|undefined} */\nRoute.prototype.matcher;\n/** @type {?|undefined} */\nRoute.prototype.component;\n/** @type {?|undefined} */\nRoute.prototype.redirectTo;\n/** @type {?|undefined} */\nRoute.prototype.outlet;\n/** @type {?|undefined} */\nRoute.prototype.canActivate;\n/** @type {?|undefined} */\nRoute.prototype.canActivateChild;\n/** @type {?|undefined} */\nRoute.prototype.canDeactivate;\n/** @type {?|undefined} */\nRoute.prototype.canLoad;\n/** @type {?|undefined} */\nRoute.prototype.data;\n/** @type {?|undefined} */\nRoute.prototype.resolve;\n/** @type {?|undefined} */\nRoute.prototype.children;\n/** @type {?|undefined} */\nRoute.prototype.loadChildren;\n/** @type {?|undefined} */\nRoute.prototype.runGuardsAndResolvers;\n/**\n * Filled for routes with `loadChildren` once the module has been loaded\n * \\@internal\n * @type {?|undefined}\n */\nRoute.prototype._loadedConfig;\nvar LoadedRouterConfig = /** @class */ (function () {\n    function LoadedRouterConfig(routes, module) {\n        this.routes = routes;\n        this.module = module;\n    }\n    return LoadedRouterConfig;\n}());\nexport { LoadedRouterConfig };\nif (false) {\n    /** @type {?} */\n    LoadedRouterConfig.prototype.routes;\n    /** @type {?} */\n    LoadedRouterConfig.prototype.module;\n}\n/**\n * @param {?} config\n * @param {?=} parentPath\n * @return {?}\n */\nexport function validateConfig(config, parentPath) {\n    if (parentPath === void 0) { parentPath = ''; }\n    // forEach doesn't iterate undefined values\n    for (var i = 0; i < config.length; i++) {\n        /** @type {?} */\n        var route = config[i];\n        /** @type {?} */\n        var fullPath = getFullPath(parentPath, route);\n        validateNode(route, fullPath);\n    }\n}\n/**\n * @param {?} route\n * @param {?} fullPath\n * @return {?}\n */\nfunction validateNode(route, fullPath) {\n    if (!route) {\n        throw new Error(\"\\n      Invalid configuration of route '\" + fullPath + \"': Encountered undefined route.\\n      The reason might be an extra comma.\\n\\n      Example:\\n      const routes: Routes = [\\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\\n        { path: 'detail/:id', component: HeroDetailComponent }\\n      ];\\n    \");\n    }\n    if (Array.isArray(route)) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': Array cannot be specified\");\n    }\n    if (!route.component && !route.children && !route.loadChildren &&\n        (route.outlet && route.outlet !== PRIMARY_OUTLET)) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': a componentless route without children or loadChildren cannot have a named outlet set\");\n    }\n    if (route.redirectTo && route.children) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': redirectTo and children cannot be used together\");\n    }\n    if (route.redirectTo && route.loadChildren) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': redirectTo and loadChildren cannot be used together\");\n    }\n    if (route.children && route.loadChildren) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': children and loadChildren cannot be used together\");\n    }\n    if (route.redirectTo && route.component) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': redirectTo and component cannot be used together\");\n    }\n    if (route.path && route.matcher) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': path and matcher cannot be used together\");\n    }\n    if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"'. One of the following must be provided: component, redirectTo, children or loadChildren\");\n    }\n    if (route.path === void 0 && route.matcher === void 0) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': routes must have either a path or a matcher specified\");\n    }\n    if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': path cannot start with a slash\");\n    }\n    if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n        /** @type {?} */\n        var exp = \"The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.\";\n        throw new Error(\"Invalid configuration of route '{path: \\\"\" + fullPath + \"\\\", redirectTo: \\\"\" + route.redirectTo + \"\\\"}': please provide 'pathMatch'. \" + exp);\n    }\n    if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': pathMatch can only be set to 'prefix' or 'full'\");\n    }\n    if (route.children) {\n        validateConfig(route.children, fullPath);\n    }\n}\n/**\n * @param {?} parentPath\n * @param {?} currentRoute\n * @return {?}\n */\nfunction getFullPath(parentPath, currentRoute) {\n    if (!currentRoute) {\n        return parentPath;\n    }\n    if (!parentPath && !currentRoute.path) {\n        return '';\n    }\n    else if (parentPath && !currentRoute.path) {\n        return parentPath + \"/\";\n    }\n    else if (!parentPath && currentRoute.path) {\n        return currentRoute.path;\n    }\n    else {\n        return parentPath + \"/\" + currentRoute.path;\n    }\n}\n/**\n * Makes a copy of the config and adds any default required properties.\n * @param {?} r\n * @return {?}\n */\nexport function standardizeConfig(r) {\n    /** @type {?} */\n    var children = r.children && r.children.map(standardizeConfig);\n    /** @type {?} */\n    var c = children ? tslib_1.__assign({}, r, { children: children }) : tslib_1.__assign({}, r);\n    if (!c.component && (children || c.loadChildren) && (c.outlet && c.outlet !== PRIMARY_OUTLET)) {\n        c.component = EmptyOutletComponent;\n    }\n    return c;\n}\n//# sourceMappingURL=config.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ɵisObservable as isObservable, ɵisPromise as isPromise } from '@angular/core';\nimport { from, of } from 'rxjs';\nimport { concatAll, every, last as lastValue, map, mergeAll } from 'rxjs/operators';\nimport { PRIMARY_OUTLET } from '../shared';\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nexport function shallowEqualArrays(a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (var i = 0; i < a.length; ++i) {\n        if (!shallowEqual(a[i], b[i]))\n            return false;\n    }\n    return true;\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nexport function shallowEqual(a, b) {\n    /** @type {?} */\n    var k1 = Object.keys(a);\n    /** @type {?} */\n    var k2 = Object.keys(b);\n    if (k1.length != k2.length) {\n        return false;\n    }\n    /** @type {?} */\n    var key;\n    for (var i = 0; i < k1.length; i++) {\n        key = k1[i];\n        if (a[key] !== b[key]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Flattens single-level nested arrays.\n * @template T\n * @param {?} arr\n * @return {?}\n */\nexport function flatten(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\n/**\n * Return the last element of an array.\n * @template T\n * @param {?} a\n * @return {?}\n */\nexport function last(a) {\n    return a.length > 0 ? a[a.length - 1] : null;\n}\n/**\n * Verifys all booleans in an array are `true`.\n * @param {?} bools\n * @return {?}\n */\nexport function and(bools) {\n    return !bools.some(function (v) { return !v; });\n}\n/**\n * @template K, V\n * @param {?} map\n * @param {?} callback\n * @return {?}\n */\nexport function forEach(map, callback) {\n    for (var prop in map) {\n        if (map.hasOwnProperty(prop)) {\n            callback(map[prop], prop);\n        }\n    }\n}\n/**\n * @template A, B\n * @param {?} obj\n * @param {?} fn\n * @return {?}\n */\nexport function waitForMap(obj, fn) {\n    if (Object.keys(obj).length === 0) {\n        return of({});\n    }\n    /** @type {?} */\n    var waitHead = [];\n    /** @type {?} */\n    var waitTail = [];\n    /** @type {?} */\n    var res = {};\n    forEach(obj, function (a, k) {\n        /** @type {?} */\n        var mapped = fn(k, a).pipe(map(function (r) { return res[k] = r; }));\n        if (k === PRIMARY_OUTLET) {\n            waitHead.push(mapped);\n        }\n        else {\n            waitTail.push(mapped);\n        }\n    });\n    // Closure compiler has problem with using spread operator here. So just using Array.concat.\n    return of.apply(null, waitHead.concat(waitTail)).pipe(concatAll(), lastValue(), map(function () { return res; }));\n}\n/**\n * ANDs Observables by merging all input observables, reducing to an Observable verifying all\n * input Observables return `true`.\n * @param {?} observables\n * @return {?}\n */\nexport function andObservables(observables) {\n    return observables.pipe(mergeAll(), every(function (result) { return result === true; }));\n}\n/**\n * @template T\n * @param {?} value\n * @return {?}\n */\nexport function wrapIntoObservable(value) {\n    if (isObservable(value)) {\n        return value;\n    }\n    if (isPromise(value)) {\n        // Use `Promise.resolve()` to wrap promise-like instances.\n        // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n        // change detection.\n        return from(Promise.resolve(value));\n    }\n    return of(/** @type {?} */ (value));\n}\n//# sourceMappingURL=collection.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { PRIMARY_OUTLET, convertToParamMap } from './shared';\nimport { forEach, shallowEqual } from './utils/collection';\n/**\n * @return {?}\n */\nexport function createEmptyUrlTree() {\n    return new UrlTree(new UrlSegmentGroup([], {}), {}, null);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @param {?} exact\n * @return {?}\n */\nexport function containsTree(container, containee, exact) {\n    if (exact) {\n        return equalQueryParams(container.queryParams, containee.queryParams) &&\n            equalSegmentGroups(container.root, containee.root);\n    }\n    return containsQueryParams(container.queryParams, containee.queryParams) &&\n        containsSegmentGroup(container.root, containee.root);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\nfunction equalQueryParams(container, containee) {\n    // TODO: This does not handle array params correctly.\n    return shallowEqual(container, containee);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\nfunction equalSegmentGroups(container, containee) {\n    if (!equalPath(container.segments, containee.segments))\n        return false;\n    if (container.numberOfChildren !== containee.numberOfChildren)\n        return false;\n    for (var c in containee.children) {\n        if (!container.children[c])\n            return false;\n        if (!equalSegmentGroups(container.children[c], containee.children[c]))\n            return false;\n    }\n    return true;\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\nfunction containsQueryParams(container, containee) {\n    // TODO: This does not handle array params correctly.\n    return Object.keys(containee).length <= Object.keys(container).length &&\n        Object.keys(containee).every(function (key) { return containee[key] === container[key]; });\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\nfunction containsSegmentGroup(container, containee) {\n    return containsSegmentGroupHelper(container, containee, containee.segments);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @param {?} containeePaths\n * @return {?}\n */\nfunction containsSegmentGroupHelper(container, containee, containeePaths) {\n    if (container.segments.length > containeePaths.length) {\n        /** @type {?} */\n        var current = container.segments.slice(0, containeePaths.length);\n        if (!equalPath(current, containeePaths))\n            return false;\n        if (containee.hasChildren())\n            return false;\n        return true;\n    }\n    else if (container.segments.length === containeePaths.length) {\n        if (!equalPath(container.segments, containeePaths))\n            return false;\n        for (var c in containee.children) {\n            if (!container.children[c])\n                return false;\n            if (!containsSegmentGroup(container.children[c], containee.children[c]))\n                return false;\n        }\n        return true;\n    }\n    else {\n        /** @type {?} */\n        var current = containeePaths.slice(0, container.segments.length);\n        /** @type {?} */\n        var next = containeePaths.slice(container.segments.length);\n        if (!equalPath(container.segments, current))\n            return false;\n        if (!container.children[PRIMARY_OUTLET])\n            return false;\n        return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);\n    }\n}\n/**\n * \\@description\n *\n * Represents the parsed URL.\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * ### Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n *\n */\nvar /**\n * \\@description\n *\n * Represents the parsed URL.\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * ### Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n *\n */\nUrlTree = /** @class */ (function () {\n    /** @internal */\n    function UrlTree(root, queryParams, fragment) {\n        this.root = root;\n        this.queryParams = queryParams;\n        this.fragment = fragment;\n    }\n    Object.defineProperty(UrlTree.prototype, \"queryParamMap\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this._queryParamMap) {\n                this._queryParamMap = convertToParamMap(this.queryParams);\n            }\n            return this._queryParamMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    UrlTree.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () { return DEFAULT_SERIALIZER.serialize(this); };\n    return UrlTree;\n}());\n/**\n * \\@description\n *\n * Represents the parsed URL.\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * ### Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n *\n */\nexport { UrlTree };\nif (false) {\n    /**\n     * \\@internal\n     * @type {?}\n     */\n    UrlTree.prototype._queryParamMap;\n    /**\n     * The root segment group of the URL tree\n     * @type {?}\n     */\n    UrlTree.prototype.root;\n    /**\n     * The query params of the URL\n     * @type {?}\n     */\n    UrlTree.prototype.queryParams;\n    /**\n     * The fragment of the URL\n     * @type {?}\n     */\n    UrlTree.prototype.fragment;\n}\n/**\n * \\@description\n *\n * Represents the parsed URL segment group.\n *\n * See `UrlTree` for more information.\n *\n *\n */\nvar /**\n * \\@description\n *\n * Represents the parsed URL segment group.\n *\n * See `UrlTree` for more information.\n *\n *\n */\nUrlSegmentGroup = /** @class */ (function () {\n    function UrlSegmentGroup(segments, children) {\n        var _this = this;\n        this.segments = segments;\n        this.children = children;\n        /**\n         * The parent node in the url tree\n         */\n        this.parent = null;\n        forEach(children, function (v, k) { return v.parent = _this; });\n    }\n    /** Whether the segment has child segments */\n    /**\n     * Whether the segment has child segments\n     * @return {?}\n     */\n    UrlSegmentGroup.prototype.hasChildren = /**\n     * Whether the segment has child segments\n     * @return {?}\n     */\n    function () { return this.numberOfChildren > 0; };\n    Object.defineProperty(UrlSegmentGroup.prototype, \"numberOfChildren\", {\n        /** Number of child segments */\n        get: /**\n         * Number of child segments\n         * @return {?}\n         */\n        function () { return Object.keys(this.children).length; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    UrlSegmentGroup.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () { return serializePaths(this); };\n    return UrlSegmentGroup;\n}());\n/**\n * \\@description\n *\n * Represents the parsed URL segment group.\n *\n * See `UrlTree` for more information.\n *\n *\n */\nexport { UrlSegmentGroup };\nif (false) {\n    /**\n     * \\@internal\n     * @type {?}\n     */\n    UrlSegmentGroup.prototype._sourceSegment;\n    /**\n     * \\@internal\n     * @type {?}\n     */\n    UrlSegmentGroup.prototype._segmentIndexShift;\n    /**\n     * The parent node in the url tree\n     * @type {?}\n     */\n    UrlSegmentGroup.prototype.parent;\n    /**\n     * The URL segments of this group. See `UrlSegment` for more information\n     * @type {?}\n     */\n    UrlSegmentGroup.prototype.segments;\n    /**\n     * The list of children of this group\n     * @type {?}\n     */\n    UrlSegmentGroup.prototype.children;\n}\n/**\n * \\@description\n *\n * Represents a single URL segment.\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n *  ## Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n *\n */\nvar /**\n * \\@description\n *\n * Represents a single URL segment.\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n *  ## Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n *\n */\nUrlSegment = /** @class */ (function () {\n    function UrlSegment(path, parameters) {\n        this.path = path;\n        this.parameters = parameters;\n    }\n    Object.defineProperty(UrlSegment.prototype, \"parameterMap\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this._parameterMap) {\n                this._parameterMap = convertToParamMap(this.parameters);\n            }\n            return this._parameterMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    UrlSegment.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () { return serializePath(this); };\n    return UrlSegment;\n}());\n/**\n * \\@description\n *\n * Represents a single URL segment.\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n *  ## Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n *\n */\nexport { UrlSegment };\nif (false) {\n    /**\n     * \\@internal\n     * @type {?}\n     */\n    UrlSegment.prototype._parameterMap;\n    /**\n     * The path part of a URL segment\n     * @type {?}\n     */\n    UrlSegment.prototype.path;\n    /**\n     * The matrix parameters associated with a segment\n     * @type {?}\n     */\n    UrlSegment.prototype.parameters;\n}\n/**\n * @param {?} as\n * @param {?} bs\n * @return {?}\n */\nexport function equalSegments(as, bs) {\n    return equalPath(as, bs) && as.every(function (a, i) { return shallowEqual(a.parameters, bs[i].parameters); });\n}\n/**\n * @param {?} as\n * @param {?} bs\n * @return {?}\n */\nexport function equalPath(as, bs) {\n    if (as.length !== bs.length)\n        return false;\n    return as.every(function (a, i) { return a.path === bs[i].path; });\n}\n/**\n * @template T\n * @param {?} segment\n * @param {?} fn\n * @return {?}\n */\nexport function mapChildrenIntoArray(segment, fn) {\n    /** @type {?} */\n    var res = [];\n    forEach(segment.children, function (child, childOutlet) {\n        if (childOutlet === PRIMARY_OUTLET) {\n            res = res.concat(fn(child, childOutlet));\n        }\n    });\n    forEach(segment.children, function (child, childOutlet) {\n        if (childOutlet !== PRIMARY_OUTLET) {\n            res = res.concat(fn(child, childOutlet));\n        }\n    });\n    return res;\n}\n/**\n * \\@description\n *\n * Serializes and deserializes a URL string into a URL tree.\n *\n * The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See `DefaultUrlSerializer` for an example of a URL serializer.\n *\n *\n * @abstract\n */\nvar /**\n * \\@description\n *\n * Serializes and deserializes a URL string into a URL tree.\n *\n * The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See `DefaultUrlSerializer` for an example of a URL serializer.\n *\n *\n * @abstract\n */\nUrlSerializer = /** @class */ (function () {\n    function UrlSerializer() {\n    }\n    return UrlSerializer;\n}());\n/**\n * \\@description\n *\n * Serializes and deserializes a URL string into a URL tree.\n *\n * The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See `DefaultUrlSerializer` for an example of a URL serializer.\n *\n *\n * @abstract\n */\nexport { UrlSerializer };\nif (false) {\n    /**\n     * Parse a url into a `UrlTree`\n     * @abstract\n     * @param {?} url\n     * @return {?}\n     */\n    UrlSerializer.prototype.parse = function (url) { };\n    /**\n     * Converts a `UrlTree` into a url\n     * @abstract\n     * @param {?} tree\n     * @return {?}\n     */\n    UrlSerializer.prototype.serialize = function (tree) { };\n}\n/**\n * \\@description\n *\n * A default implementation of the `UrlSerializer`.\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n *\n */\nvar /**\n * \\@description\n *\n * A default implementation of the `UrlSerializer`.\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n *\n */\nDefaultUrlSerializer = /** @class */ (function () {\n    function DefaultUrlSerializer() {\n    }\n    /** Parses a url into a `UrlTree` */\n    /**\n     * Parses a url into a `UrlTree`\n     * @param {?} url\n     * @return {?}\n     */\n    DefaultUrlSerializer.prototype.parse = /**\n     * Parses a url into a `UrlTree`\n     * @param {?} url\n     * @return {?}\n     */\n    function (url) {\n        /** @type {?} */\n        var p = new UrlParser(url);\n        return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n    };\n    /** Converts a `UrlTree` into a url */\n    /**\n     * Converts a `UrlTree` into a url\n     * @param {?} tree\n     * @return {?}\n     */\n    DefaultUrlSerializer.prototype.serialize = /**\n     * Converts a `UrlTree` into a url\n     * @param {?} tree\n     * @return {?}\n     */\n    function (tree) {\n        /** @type {?} */\n        var segment = \"/\" + serializeSegment(tree.root, true);\n        /** @type {?} */\n        var query = serializeQueryParams(tree.queryParams);\n        /** @type {?} */\n        var fragment = typeof tree.fragment === \"string\" ? \"#\" + encodeUriFragment((/** @type {?} */ ((tree.fragment)))) : '';\n        return \"\" + segment + query + fragment;\n    };\n    return DefaultUrlSerializer;\n}());\n/**\n * \\@description\n *\n * A default implementation of the `UrlSerializer`.\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n *\n */\nexport { DefaultUrlSerializer };\n/** @type {?} */\nvar DEFAULT_SERIALIZER = new DefaultUrlSerializer();\n/**\n * @param {?} segment\n * @return {?}\n */\nexport function serializePaths(segment) {\n    return segment.segments.map(function (p) { return serializePath(p); }).join('/');\n}\n/**\n * @param {?} segment\n * @param {?} root\n * @return {?}\n */\nfunction serializeSegment(segment, root) {\n    if (!segment.hasChildren()) {\n        return serializePaths(segment);\n    }\n    if (root) {\n        /** @type {?} */\n        var primary = segment.children[PRIMARY_OUTLET] ?\n            serializeSegment(segment.children[PRIMARY_OUTLET], false) :\n            '';\n        /** @type {?} */\n        var children_1 = [];\n        forEach(segment.children, function (v, k) {\n            if (k !== PRIMARY_OUTLET) {\n                children_1.push(k + \":\" + serializeSegment(v, false));\n            }\n        });\n        return children_1.length > 0 ? primary + \"(\" + children_1.join('//') + \")\" : primary;\n    }\n    else {\n        /** @type {?} */\n        var children = mapChildrenIntoArray(segment, function (v, k) {\n            if (k === PRIMARY_OUTLET) {\n                return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n            }\n            return [k + \":\" + serializeSegment(v, false)];\n        });\n        return serializePaths(segment) + \"/(\" + children.join('//') + \")\";\n    }\n}\n/**\n * Encodes a URI string with the default encoding. This function will only ever be called from\n * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need\n * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't\n * have to be encoded per https://url.spec.whatwg.org.\n * @param {?} s\n * @return {?}\n */\nfunction encodeUriString(s) {\n    return encodeURIComponent(s)\n        .replace(/%40/g, '@')\n        .replace(/%3A/gi, ':')\n        .replace(/%24/g, '$')\n        .replace(/%2C/gi, ',');\n}\n/**\n * This function should be used to encode both keys and values in a query string key/value. In\n * the following URL, you need to call encodeUriQuery on \"k\" and \"v\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n * @param {?} s\n * @return {?}\n */\nexport function encodeUriQuery(s) {\n    return encodeUriString(s).replace(/%3B/gi, ';');\n}\n/**\n * This function should be used to encode a URL fragment. In the following URL, you need to call\n * encodeUriFragment on \"f\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n * @param {?} s\n * @return {?}\n */\nexport function encodeUriFragment(s) {\n    return encodeURI(s);\n}\n/**\n * This function should be run on any URI segment as well as the key and value in a key/value\n * pair for matrix params. In the following URL, you need to call encodeUriSegment on \"html\",\n * \"mk\", and \"mv\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n * @param {?} s\n * @return {?}\n */\nexport function encodeUriSegment(s) {\n    return encodeUriString(s).replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/%26/gi, '&');\n}\n/**\n * @param {?} s\n * @return {?}\n */\nexport function decode(s) {\n    return decodeURIComponent(s);\n}\n/**\n * @param {?} s\n * @return {?}\n */\nexport function decodeQuery(s) {\n    return decode(s.replace(/\\+/g, '%20'));\n}\n/**\n * @param {?} path\n * @return {?}\n */\nexport function serializePath(path) {\n    return \"\" + encodeUriSegment(path.path) + serializeMatrixParams(path.parameters);\n}\n/**\n * @param {?} params\n * @return {?}\n */\nfunction serializeMatrixParams(params) {\n    return Object.keys(params)\n        .map(function (key) { return \";\" + encodeUriSegment(key) + \"=\" + encodeUriSegment(params[key]); })\n        .join('');\n}\n/**\n * @param {?} params\n * @return {?}\n */\nfunction serializeQueryParams(params) {\n    /** @type {?} */\n    var strParams = Object.keys(params).map(function (name) {\n        /** @type {?} */\n        var value = params[name];\n        return Array.isArray(value) ?\n            value.map(function (v) { return encodeUriQuery(name) + \"=\" + encodeUriQuery(v); }).join('&') :\n            encodeUriQuery(name) + \"=\" + encodeUriQuery(value);\n    });\n    return strParams.length ? \"?\" + strParams.join(\"&\") : '';\n}\n/** @type {?} */\nvar SEGMENT_RE = /^[^\\/()?;=#]+/;\n/**\n * @param {?} str\n * @return {?}\n */\nfunction matchSegments(str) {\n    /** @type {?} */\n    var match = str.match(SEGMENT_RE);\n    return match ? match[0] : '';\n}\n/** @type {?} */\nvar QUERY_PARAM_RE = /^[^=?&#]+/;\n/**\n * @param {?} str\n * @return {?}\n */\nfunction matchQueryParams(str) {\n    /** @type {?} */\n    var match = str.match(QUERY_PARAM_RE);\n    return match ? match[0] : '';\n}\n/** @type {?} */\nvar QUERY_PARAM_VALUE_RE = /^[^?&#]+/;\n/**\n * @param {?} str\n * @return {?}\n */\nfunction matchUrlQueryParamValue(str) {\n    /** @type {?} */\n    var match = str.match(QUERY_PARAM_VALUE_RE);\n    return match ? match[0] : '';\n}\nvar UrlParser = /** @class */ (function () {\n    function UrlParser(url) {\n        this.url = url;\n        this.remaining = url;\n    }\n    /**\n     * @return {?}\n     */\n    UrlParser.prototype.parseRootSegment = /**\n     * @return {?}\n     */\n    function () {\n        this.consumeOptional('/');\n        if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\n            return new UrlSegmentGroup([], {});\n        }\n        // The root segment group never has segments\n        return new UrlSegmentGroup([], this.parseChildren());\n    };\n    /**\n     * @return {?}\n     */\n    UrlParser.prototype.parseQueryParams = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var params = {};\n        if (this.consumeOptional('?')) {\n            do {\n                this.parseQueryParam(params);\n            } while (this.consumeOptional('&'));\n        }\n        return params;\n    };\n    /**\n     * @return {?}\n     */\n    UrlParser.prototype.parseFragment = /**\n     * @return {?}\n     */\n    function () {\n        return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;\n    };\n    /**\n     * @return {?}\n     */\n    UrlParser.prototype.parseChildren = /**\n     * @return {?}\n     */\n    function () {\n        if (this.remaining === '') {\n            return {};\n        }\n        this.consumeOptional('/');\n        /** @type {?} */\n        var segments = [];\n        if (!this.peekStartsWith('(')) {\n            segments.push(this.parseSegment());\n        }\n        while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n            this.capture('/');\n            segments.push(this.parseSegment());\n        }\n        /** @type {?} */\n        var children = {};\n        if (this.peekStartsWith('/(')) {\n            this.capture('/');\n            children = this.parseParens(true);\n        }\n        /** @type {?} */\n        var res = {};\n        if (this.peekStartsWith('(')) {\n            res = this.parseParens(false);\n        }\n        if (segments.length > 0 || Object.keys(children).length > 0) {\n            res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n        }\n        return res;\n    };\n    /**\n     * @return {?}\n     */\n    UrlParser.prototype.parseSegment = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var path = matchSegments(this.remaining);\n        if (path === '' && this.peekStartsWith(';')) {\n            throw new Error(\"Empty path url segment cannot have parameters: '\" + this.remaining + \"'.\");\n        }\n        this.capture(path);\n        return new UrlSegment(decode(path), this.parseMatrixParams());\n    };\n    /**\n     * @return {?}\n     */\n    UrlParser.prototype.parseMatrixParams = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var params = {};\n        while (this.consumeOptional(';')) {\n            this.parseParam(params);\n        }\n        return params;\n    };\n    /**\n     * @param {?} params\n     * @return {?}\n     */\n    UrlParser.prototype.parseParam = /**\n     * @param {?} params\n     * @return {?}\n     */\n    function (params) {\n        /** @type {?} */\n        var key = matchSegments(this.remaining);\n        if (!key) {\n            return;\n        }\n        this.capture(key);\n        /** @type {?} */\n        var value = '';\n        if (this.consumeOptional('=')) {\n            /** @type {?} */\n            var valueMatch = matchSegments(this.remaining);\n            if (valueMatch) {\n                value = valueMatch;\n                this.capture(value);\n            }\n        }\n        params[decode(key)] = decode(value);\n    };\n    /**\n     * @param {?} params\n     * @return {?}\n     */\n    UrlParser.prototype.parseQueryParam = /**\n     * @param {?} params\n     * @return {?}\n     */\n    function (params) {\n        /** @type {?} */\n        var key = matchQueryParams(this.remaining);\n        if (!key) {\n            return;\n        }\n        this.capture(key);\n        /** @type {?} */\n        var value = '';\n        if (this.consumeOptional('=')) {\n            /** @type {?} */\n            var valueMatch = matchUrlQueryParamValue(this.remaining);\n            if (valueMatch) {\n                value = valueMatch;\n                this.capture(value);\n            }\n        }\n        /** @type {?} */\n        var decodedKey = decodeQuery(key);\n        /** @type {?} */\n        var decodedVal = decodeQuery(value);\n        if (params.hasOwnProperty(decodedKey)) {\n            /** @type {?} */\n            var currentVal = params[decodedKey];\n            if (!Array.isArray(currentVal)) {\n                currentVal = [currentVal];\n                params[decodedKey] = currentVal;\n            }\n            currentVal.push(decodedVal);\n        }\n        else {\n            // Create a new value\n            params[decodedKey] = decodedVal;\n        }\n    };\n    /**\n     * @param {?} allowPrimary\n     * @return {?}\n     */\n    UrlParser.prototype.parseParens = /**\n     * @param {?} allowPrimary\n     * @return {?}\n     */\n    function (allowPrimary) {\n        /** @type {?} */\n        var segments = {};\n        this.capture('(');\n        while (!this.consumeOptional(')') && this.remaining.length > 0) {\n            /** @type {?} */\n            var path = matchSegments(this.remaining);\n            /** @type {?} */\n            var next = this.remaining[path.length];\n            // if is is not one of these characters, then the segment was unescaped\n            // or the group was not closed\n            if (next !== '/' && next !== ')' && next !== ';') {\n                throw new Error(\"Cannot parse url '\" + this.url + \"'\");\n            }\n            /** @type {?} */\n            var outletName = /** @type {?} */ ((undefined));\n            if (path.indexOf(':') > -1) {\n                outletName = path.substr(0, path.indexOf(':'));\n                this.capture(outletName);\n                this.capture(':');\n            }\n            else if (allowPrimary) {\n                outletName = PRIMARY_OUTLET;\n            }\n            /** @type {?} */\n            var children = this.parseChildren();\n            segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :\n                new UrlSegmentGroup([], children);\n            this.consumeOptional('//');\n        }\n        return segments;\n    };\n    /**\n     * @param {?} str\n     * @return {?}\n     */\n    UrlParser.prototype.peekStartsWith = /**\n     * @param {?} str\n     * @return {?}\n     */\n    function (str) { return this.remaining.startsWith(str); };\n    /**\n     * @param {?} str\n     * @return {?}\n     */\n    UrlParser.prototype.consumeOptional = /**\n     * @param {?} str\n     * @return {?}\n     */\n    function (str) {\n        if (this.peekStartsWith(str)) {\n            this.remaining = this.remaining.substring(str.length);\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} str\n     * @return {?}\n     */\n    UrlParser.prototype.capture = /**\n     * @param {?} str\n     * @return {?}\n     */\n    function (str) {\n        if (!this.consumeOptional(str)) {\n            throw new Error(\"Expected \\\"\" + str + \"\\\".\");\n        }\n    };\n    return UrlParser;\n}());\nif (false) {\n    /** @type {?} */\n    UrlParser.prototype.remaining;\n    /** @type {?} */\n    UrlParser.prototype.url;\n}\n//# sourceMappingURL=url_tree.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as tslib_1 from \"tslib\";\nimport { NgModuleRef } from '@angular/core';\nimport { EmptyError, Observable, from, of } from 'rxjs';\nimport { catchError, concatAll, first, map, mergeMap } from 'rxjs/operators';\nimport { LoadedRouterConfig } from './config';\nimport { PRIMARY_OUTLET, defaultUrlMatcher, navigationCancelingError } from './shared';\nimport { UrlSegmentGroup, UrlTree } from './url_tree';\nimport { andObservables, forEach, waitForMap, wrapIntoObservable } from './utils/collection';\nvar NoMatch = /** @class */ (function () {\n    function NoMatch(segmentGroup) {\n        this.segmentGroup = segmentGroup || null;\n    }\n    return NoMatch;\n}());\nif (false) {\n    /** @type {?} */\n    NoMatch.prototype.segmentGroup;\n}\nvar AbsoluteRedirect = /** @class */ (function () {\n    function AbsoluteRedirect(urlTree) {\n        this.urlTree = urlTree;\n    }\n    return AbsoluteRedirect;\n}());\nif (false) {\n    /** @type {?} */\n    AbsoluteRedirect.prototype.urlTree;\n}\n/**\n * @param {?} segmentGroup\n * @return {?}\n */\nfunction noMatch(segmentGroup) {\n    return new Observable(function (obs) { return obs.error(new NoMatch(segmentGroup)); });\n}\n/**\n * @param {?} newTree\n * @return {?}\n */\nfunction absoluteRedirect(newTree) {\n    return new Observable(function (obs) { return obs.error(new AbsoluteRedirect(newTree)); });\n}\n/**\n * @param {?} redirectTo\n * @return {?}\n */\nfunction namedOutletsRedirect(redirectTo) {\n    return new Observable(function (obs) { return obs.error(new Error(\"Only absolute redirects can have named outlets. redirectTo: '\" + redirectTo + \"'\")); });\n}\n/**\n * @param {?} route\n * @return {?}\n */\nfunction canLoadFails(route) {\n    return new Observable(function (obs) { return obs.error(navigationCancelingError(\"Cannot load children because the guard of the route \\\"path: '\" + route.path + \"'\\\" returned false\")); });\n}\n/**\n * Returns the `UrlTree` with the redirection applied.\n *\n * Lazy modules are loaded along the way.\n * @param {?} moduleInjector\n * @param {?} configLoader\n * @param {?} urlSerializer\n * @param {?} urlTree\n * @param {?} config\n * @return {?}\n */\nexport function applyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {\n    return new ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config).apply();\n}\nvar ApplyRedirects = /** @class */ (function () {\n    function ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {\n        this.configLoader = configLoader;\n        this.urlSerializer = urlSerializer;\n        this.urlTree = urlTree;\n        this.config = config;\n        this.allowRedirects = true;\n        this.ngModule = moduleInjector.get(NgModuleRef);\n    }\n    /**\n     * @return {?}\n     */\n    ApplyRedirects.prototype.apply = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        /** @type {?} */\n        var expanded$ = this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, PRIMARY_OUTLET);\n        /** @type {?} */\n        var urlTrees$ = expanded$.pipe(map(function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup, _this.urlTree.queryParams, /** @type {?} */ ((_this.urlTree.fragment))); }));\n        return urlTrees$.pipe(catchError(function (e) {\n            if (e instanceof AbsoluteRedirect) {\n                // after an absolute redirect we do not apply any more redirects!\n                // after an absolute redirect we do not apply any more redirects!\n                _this.allowRedirects = false;\n                // we need to run matching, so we can fetch all lazy-loaded modules\n                return _this.match(e.urlTree);\n            }\n            if (e instanceof NoMatch) {\n                throw _this.noMatchError(e);\n            }\n            throw e;\n        }));\n    };\n    /**\n     * @param {?} tree\n     * @return {?}\n     */\n    ApplyRedirects.prototype.match = /**\n     * @param {?} tree\n     * @return {?}\n     */\n    function (tree) {\n        var _this = this;\n        /** @type {?} */\n        var expanded$ = this.expandSegmentGroup(this.ngModule, this.config, tree.root, PRIMARY_OUTLET);\n        /** @type {?} */\n        var mapped$ = expanded$.pipe(map(function (rootSegmentGroup) {\n            return _this.createUrlTree(rootSegmentGroup, tree.queryParams, /** @type {?} */ ((tree.fragment)));\n        }));\n        return mapped$.pipe(catchError(function (e) {\n            if (e instanceof NoMatch) {\n                throw _this.noMatchError(e);\n            }\n            throw e;\n        }));\n    };\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    ApplyRedirects.prototype.noMatchError = /**\n     * @param {?} e\n     * @return {?}\n     */\n    function (e) {\n        return new Error(\"Cannot match any routes. URL Segment: '\" + e.segmentGroup + \"'\");\n    };\n    /**\n     * @param {?} rootCandidate\n     * @param {?} queryParams\n     * @param {?} fragment\n     * @return {?}\n     */\n    ApplyRedirects.prototype.createUrlTree = /**\n     * @param {?} rootCandidate\n     * @param {?} queryParams\n     * @param {?} fragment\n     * @return {?}\n     */\n    function (rootCandidate, queryParams, fragment) {\n        var _a;\n        /** @type {?} */\n        var root = rootCandidate.segments.length > 0 ?\n            new UrlSegmentGroup([], (_a = {}, _a[PRIMARY_OUTLET] = rootCandidate, _a)) :\n            rootCandidate;\n        return new UrlTree(root, queryParams, fragment);\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} segmentGroup\n     * @param {?} outlet\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandSegmentGroup = /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} segmentGroup\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (ngModule, routes, segmentGroup, outlet) {\n        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n            return this.expandChildren(ngModule, routes, segmentGroup)\n                .pipe(map(function (children) { return new UrlSegmentGroup([], children); }));\n        }\n        return this.expandSegment(ngModule, segmentGroup, routes, segmentGroup.segments, outlet, true);\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} segmentGroup\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandChildren = /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} segmentGroup\n     * @return {?}\n     */\n    function (ngModule, routes, segmentGroup) {\n        var _this = this;\n        return waitForMap(segmentGroup.children, function (childOutlet, child) { return _this.expandSegmentGroup(ngModule, routes, child, childOutlet); });\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} segments\n     * @param {?} outlet\n     * @param {?} allowRedirects\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandSegment = /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} segments\n     * @param {?} outlet\n     * @param {?} allowRedirects\n     * @return {?}\n     */\n    function (ngModule, segmentGroup, routes, segments, outlet, allowRedirects) {\n        var _this = this;\n        return of.apply(void 0, routes).pipe(map(function (r) {\n            /** @type {?} */\n            var expanded$ = _this.expandSegmentAgainstRoute(ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);\n            return expanded$.pipe(catchError(function (e) {\n                if (e instanceof NoMatch) {\n                    // TODO(i): this return type doesn't match the declared Observable<UrlSegmentGroup> -\n                    // talk to Jason\n                    return /** @type {?} */ (of(null));\n                }\n                throw e;\n            }));\n        }), concatAll(), first(function (s) { return !!s; }), catchError(function (e, _) {\n            if (e instanceof EmptyError || e.name === 'EmptyError') {\n                if (_this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n                    return of(new UrlSegmentGroup([], {}));\n                }\n                throw new NoMatch(segmentGroup);\n            }\n            throw e;\n        }));\n    };\n    /**\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    ApplyRedirects.prototype.noLeftoversInUrl = /**\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (segmentGroup, segments, outlet) {\n        return segments.length === 0 && !segmentGroup.children[outlet];\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} paths\n     * @param {?} outlet\n     * @param {?} allowRedirects\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandSegmentAgainstRoute = /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} paths\n     * @param {?} outlet\n     * @param {?} allowRedirects\n     * @return {?}\n     */\n    function (ngModule, segmentGroup, routes, route, paths, outlet, allowRedirects) {\n        if (getOutlet(route) !== outlet) {\n            return noMatch(segmentGroup);\n        }\n        if (route.redirectTo === undefined) {\n            return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths);\n        }\n        if (allowRedirects && this.allowRedirects) {\n            return this.expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, paths, outlet);\n        }\n        return noMatch(segmentGroup);\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandSegmentAgainstRouteUsingRedirect = /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (ngModule, segmentGroup, routes, route, segments, outlet) {\n        if (route.path === '**') {\n            return this.expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet);\n        }\n        return this.expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet);\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} outlet\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandWildCardWithParamsAgainstRouteUsingRedirect = /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (ngModule, routes, route, outlet) {\n        var _this = this;\n        /** @type {?} */\n        var newTree = this.applyRedirectCommands([], /** @type {?} */ ((route.redirectTo)), {});\n        if (/** @type {?} */ ((route.redirectTo)).startsWith('/')) {\n            return absoluteRedirect(newTree);\n        }\n        return this.lineralizeSegments(route, newTree).pipe(mergeMap(function (newSegments) {\n            /** @type {?} */\n            var group = new UrlSegmentGroup(newSegments, {});\n            return _this.expandSegment(ngModule, group, routes, newSegments, outlet, false);\n        }));\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandRegularSegmentAgainstRouteUsingRedirect = /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (ngModule, segmentGroup, routes, route, segments, outlet) {\n        var _this = this;\n        var _a = match(segmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild, positionalParamSegments = _a.positionalParamSegments;\n        if (!matched)\n            return noMatch(segmentGroup);\n        /** @type {?} */\n        var newTree = this.applyRedirectCommands(consumedSegments, /** @type {?} */ ((route.redirectTo)), /** @type {?} */ (positionalParamSegments));\n        if (/** @type {?} */ ((route.redirectTo)).startsWith('/')) {\n            return absoluteRedirect(newTree);\n        }\n        return this.lineralizeSegments(route, newTree).pipe(mergeMap(function (newSegments) {\n            return _this.expandSegment(ngModule, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);\n        }));\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} rawSegmentGroup\n     * @param {?} route\n     * @param {?} segments\n     * @return {?}\n     */\n    ApplyRedirects.prototype.matchSegmentAgainstRoute = /**\n     * @param {?} ngModule\n     * @param {?} rawSegmentGroup\n     * @param {?} route\n     * @param {?} segments\n     * @return {?}\n     */\n    function (ngModule, rawSegmentGroup, route, segments) {\n        var _this = this;\n        if (route.path === '**') {\n            if (route.loadChildren) {\n                return this.configLoader.load(ngModule.injector, route)\n                    .pipe(map(function (cfg) {\n                    route._loadedConfig = cfg;\n                    return new UrlSegmentGroup(segments, {});\n                }));\n            }\n            return of(new UrlSegmentGroup(segments, {}));\n        }\n        var _a = match(rawSegmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild;\n        if (!matched)\n            return noMatch(rawSegmentGroup);\n        /** @type {?} */\n        var rawSlicedSegments = segments.slice(lastChild);\n        /** @type {?} */\n        var childConfig$ = this.getChildConfig(ngModule, route, segments);\n        return childConfig$.pipe(mergeMap(function (routerConfig) {\n            /** @type {?} */\n            var childModule = routerConfig.module;\n            /** @type {?} */\n            var childConfig = routerConfig.routes;\n            var _a = split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;\n            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n                /** @type {?} */\n                var expanded$_1 = _this.expandChildren(childModule, childConfig, segmentGroup);\n                return expanded$_1.pipe(map(function (children) { return new UrlSegmentGroup(consumedSegments, children); }));\n            }\n            if (childConfig.length === 0 && slicedSegments.length === 0) {\n                return of(new UrlSegmentGroup(consumedSegments, {}));\n            }\n            /** @type {?} */\n            var expanded$ = _this.expandSegment(childModule, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);\n            return expanded$.pipe(map(function (cs) {\n                return new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children);\n            }));\n        }));\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} route\n     * @param {?} segments\n     * @return {?}\n     */\n    ApplyRedirects.prototype.getChildConfig = /**\n     * @param {?} ngModule\n     * @param {?} route\n     * @param {?} segments\n     * @return {?}\n     */\n    function (ngModule, route, segments) {\n        var _this = this;\n        if (route.children) {\n            // The children belong to the same module\n            return of(new LoadedRouterConfig(route.children, ngModule));\n        }\n        if (route.loadChildren) {\n            // lazy children belong to the loaded module\n            if (route._loadedConfig !== undefined) {\n                return of(route._loadedConfig);\n            }\n            return runCanLoadGuard(ngModule.injector, route, segments)\n                .pipe(mergeMap(function (shouldLoad) {\n                if (shouldLoad) {\n                    return _this.configLoader.load(ngModule.injector, route)\n                        .pipe(map(function (cfg) {\n                        route._loadedConfig = cfg;\n                        return cfg;\n                    }));\n                }\n                return canLoadFails(route);\n            }));\n        }\n        return of(new LoadedRouterConfig([], ngModule));\n    };\n    /**\n     * @param {?} route\n     * @param {?} urlTree\n     * @return {?}\n     */\n    ApplyRedirects.prototype.lineralizeSegments = /**\n     * @param {?} route\n     * @param {?} urlTree\n     * @return {?}\n     */\n    function (route, urlTree) {\n        /** @type {?} */\n        var res = [];\n        /** @type {?} */\n        var c = urlTree.root;\n        while (true) {\n            res = res.concat(c.segments);\n            if (c.numberOfChildren === 0) {\n                return of(res);\n            }\n            if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n                return namedOutletsRedirect(/** @type {?} */ ((route.redirectTo)));\n            }\n            c = c.children[PRIMARY_OUTLET];\n        }\n    };\n    /**\n     * @param {?} segments\n     * @param {?} redirectTo\n     * @param {?} posParams\n     * @return {?}\n     */\n    ApplyRedirects.prototype.applyRedirectCommands = /**\n     * @param {?} segments\n     * @param {?} redirectTo\n     * @param {?} posParams\n     * @return {?}\n     */\n    function (segments, redirectTo, posParams) {\n        return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);\n    };\n    /**\n     * @param {?} redirectTo\n     * @param {?} urlTree\n     * @param {?} segments\n     * @param {?} posParams\n     * @return {?}\n     */\n    ApplyRedirects.prototype.applyRedirectCreatreUrlTree = /**\n     * @param {?} redirectTo\n     * @param {?} urlTree\n     * @param {?} segments\n     * @param {?} posParams\n     * @return {?}\n     */\n    function (redirectTo, urlTree, segments, posParams) {\n        /** @type {?} */\n        var newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n        return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\n    };\n    /**\n     * @param {?} redirectToParams\n     * @param {?} actualParams\n     * @return {?}\n     */\n    ApplyRedirects.prototype.createQueryParams = /**\n     * @param {?} redirectToParams\n     * @param {?} actualParams\n     * @return {?}\n     */\n    function (redirectToParams, actualParams) {\n        /** @type {?} */\n        var res = {};\n        forEach(redirectToParams, function (v, k) {\n            /** @type {?} */\n            var copySourceValue = typeof v === 'string' && v.startsWith(':');\n            if (copySourceValue) {\n                /** @type {?} */\n                var sourceName = v.substring(1);\n                res[k] = actualParams[sourceName];\n            }\n            else {\n                res[k] = v;\n            }\n        });\n        return res;\n    };\n    /**\n     * @param {?} redirectTo\n     * @param {?} group\n     * @param {?} segments\n     * @param {?} posParams\n     * @return {?}\n     */\n    ApplyRedirects.prototype.createSegmentGroup = /**\n     * @param {?} redirectTo\n     * @param {?} group\n     * @param {?} segments\n     * @param {?} posParams\n     * @return {?}\n     */\n    function (redirectTo, group, segments, posParams) {\n        var _this = this;\n        /** @type {?} */\n        var updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n        /** @type {?} */\n        var children = {};\n        forEach(group.children, function (child, name) {\n            children[name] = _this.createSegmentGroup(redirectTo, child, segments, posParams);\n        });\n        return new UrlSegmentGroup(updatedSegments, children);\n    };\n    /**\n     * @param {?} redirectTo\n     * @param {?} redirectToSegments\n     * @param {?} actualSegments\n     * @param {?} posParams\n     * @return {?}\n     */\n    ApplyRedirects.prototype.createSegments = /**\n     * @param {?} redirectTo\n     * @param {?} redirectToSegments\n     * @param {?} actualSegments\n     * @param {?} posParams\n     * @return {?}\n     */\n    function (redirectTo, redirectToSegments, actualSegments, posParams) {\n        var _this = this;\n        return redirectToSegments.map(function (s) { return s.path.startsWith(':') ? _this.findPosParam(redirectTo, s, posParams) :\n            _this.findOrReturn(s, actualSegments); });\n    };\n    /**\n     * @param {?} redirectTo\n     * @param {?} redirectToUrlSegment\n     * @param {?} posParams\n     * @return {?}\n     */\n    ApplyRedirects.prototype.findPosParam = /**\n     * @param {?} redirectTo\n     * @param {?} redirectToUrlSegment\n     * @param {?} posParams\n     * @return {?}\n     */\n    function (redirectTo, redirectToUrlSegment, posParams) {\n        /** @type {?} */\n        var pos = posParams[redirectToUrlSegment.path.substring(1)];\n        if (!pos)\n            throw new Error(\"Cannot redirect to '\" + redirectTo + \"'. Cannot find '\" + redirectToUrlSegment.path + \"'.\");\n        return pos;\n    };\n    /**\n     * @param {?} redirectToUrlSegment\n     * @param {?} actualSegments\n     * @return {?}\n     */\n    ApplyRedirects.prototype.findOrReturn = /**\n     * @param {?} redirectToUrlSegment\n     * @param {?} actualSegments\n     * @return {?}\n     */\n    function (redirectToUrlSegment, actualSegments) {\n        /** @type {?} */\n        var idx = 0;\n        for (var _i = 0, actualSegments_1 = actualSegments; _i < actualSegments_1.length; _i++) {\n            var s = actualSegments_1[_i];\n            if (s.path === redirectToUrlSegment.path) {\n                actualSegments.splice(idx);\n                return s;\n            }\n            idx++;\n        }\n        return redirectToUrlSegment;\n    };\n    return ApplyRedirects;\n}());\nif (false) {\n    /** @type {?} */\n    ApplyRedirects.prototype.allowRedirects;\n    /** @type {?} */\n    ApplyRedirects.prototype.ngModule;\n    /** @type {?} */\n    ApplyRedirects.prototype.configLoader;\n    /** @type {?} */\n    ApplyRedirects.prototype.urlSerializer;\n    /** @type {?} */\n    ApplyRedirects.prototype.urlTree;\n    /** @type {?} */\n    ApplyRedirects.prototype.config;\n}\n/**\n * @param {?} moduleInjector\n * @param {?} route\n * @param {?} segments\n * @return {?}\n */\nfunction runCanLoadGuard(moduleInjector, route, segments) {\n    /** @type {?} */\n    var canLoad = route.canLoad;\n    if (!canLoad || canLoad.length === 0)\n        return of(true);\n    /** @type {?} */\n    var obs = from(canLoad).pipe(map(function (injectionToken) {\n        /** @type {?} */\n        var guard = moduleInjector.get(injectionToken);\n        return wrapIntoObservable(guard.canLoad ? guard.canLoad(route, segments) : guard(route, segments));\n    }));\n    return andObservables(obs);\n}\n/**\n * @param {?} segmentGroup\n * @param {?} route\n * @param {?} segments\n * @return {?}\n */\nfunction match(segmentGroup, route, segments) {\n    if (route.path === '') {\n        if ((route.pathMatch === 'full') && (segmentGroup.hasChildren() || segments.length > 0)) {\n            return { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n        }\n        return { matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n    }\n    /** @type {?} */\n    var matcher = route.matcher || defaultUrlMatcher;\n    /** @type {?} */\n    var res = matcher(segments, segmentGroup, route);\n    if (!res) {\n        return {\n            matched: false,\n            consumedSegments: /** @type {?} */ ([]),\n            lastChild: 0,\n            positionalParamSegments: {},\n        };\n    }\n    return {\n        matched: true,\n        consumedSegments: /** @type {?} */ ((res.consumed)),\n        lastChild: /** @type {?} */ ((res.consumed.length)),\n        positionalParamSegments: /** @type {?} */ ((res.posParams)),\n    };\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} slicedSegments\n * @param {?} config\n * @return {?}\n */\nfunction split(segmentGroup, consumedSegments, slicedSegments, config) {\n    if (slicedSegments.length > 0 &&\n        containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n        /** @type {?} */\n        var s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n        return { segmentGroup: mergeTrivialChildren(s), slicedSegments: [] };\n    }\n    if (slicedSegments.length === 0 &&\n        containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {\n        /** @type {?} */\n        var s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n        return { segmentGroup: mergeTrivialChildren(s), slicedSegments: slicedSegments };\n    }\n    return { segmentGroup: segmentGroup, slicedSegments: slicedSegments };\n}\n/**\n * @param {?} s\n * @return {?}\n */\nfunction mergeTrivialChildren(s) {\n    if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n        /** @type {?} */\n        var c = s.children[PRIMARY_OUTLET];\n        return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n    }\n    return s;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @param {?} children\n * @return {?}\n */\nfunction addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n    /** @type {?} */\n    var res = {};\n    for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n        var r = routes_1[_i];\n        if (isEmptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n            res[getOutlet(r)] = new UrlSegmentGroup([], {});\n        }\n    }\n    return tslib_1.__assign({}, children, res);\n}\n/**\n * @param {?} routes\n * @param {?} primarySegmentGroup\n * @return {?}\n */\nfunction createChildrenForEmptySegments(routes, primarySegmentGroup) {\n    /** @type {?} */\n    var res = {};\n    res[PRIMARY_OUTLET] = primarySegmentGroup;\n    for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {\n        var r = routes_2[_i];\n        if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n            res[getOutlet(r)] = new UrlSegmentGroup([], {});\n        }\n    }\n    return res;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} segments\n * @param {?} routes\n * @return {?}\n */\nfunction containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, segments, routes) {\n    return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r) && getOutlet(r) !== PRIMARY_OUTLET; });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} segments\n * @param {?} routes\n * @return {?}\n */\nfunction containsEmptyPathRedirects(segmentGroup, segments, routes) {\n    return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r); });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} segments\n * @param {?} r\n * @return {?}\n */\nfunction isEmptyPathRedirect(segmentGroup, segments, r) {\n    if ((segmentGroup.hasChildren() || segments.length > 0) && r.pathMatch === 'full') {\n        return false;\n    }\n    return r.path === '' && r.redirectTo !== undefined;\n}\n/**\n * @param {?} route\n * @return {?}\n */\nfunction getOutlet(route) {\n    return route.outlet || PRIMARY_OUTLET;\n}\n//# sourceMappingURL=apply_redirects.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @template T\n */\nvar /**\n * @template T\n */\nTree = /** @class */ (function () {\n    function Tree(root) {\n        this._root = root;\n    }\n    Object.defineProperty(Tree.prototype, \"root\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this._root.value; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    Tree.prototype.parent = /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    function (t) {\n        /** @type {?} */\n        var p = this.pathFromRoot(t);\n        return p.length > 1 ? p[p.length - 2] : null;\n    };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    Tree.prototype.children = /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    function (t) {\n        /** @type {?} */\n        var n = findNode(t, this._root);\n        return n ? n.children.map(function (t) { return t.value; }) : [];\n    };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    Tree.prototype.firstChild = /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    function (t) {\n        /** @type {?} */\n        var n = findNode(t, this._root);\n        return n && n.children.length > 0 ? n.children[0].value : null;\n    };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    Tree.prototype.siblings = /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    function (t) {\n        /** @type {?} */\n        var p = findPath(t, this._root);\n        if (p.length < 2)\n            return [];\n        /** @type {?} */\n        var c = p[p.length - 2].children.map(function (c) { return c.value; });\n        return c.filter(function (cc) { return cc !== t; });\n    };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    Tree.prototype.pathFromRoot = /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    function (t) { return findPath(t, this._root).map(function (s) { return s.value; }); };\n    return Tree;\n}());\n/**\n * @template T\n */\nexport { Tree };\nif (false) {\n    /**\n     * \\@internal\n     * @type {?}\n     */\n    Tree.prototype._root;\n}\n/**\n * @template T\n * @param {?} value\n * @param {?} node\n * @return {?}\n */\nfunction findNode(value, node) {\n    if (value === node.value)\n        return node;\n    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n        var child = _a[_i];\n        /** @type {?} */\n        var node_1 = findNode(value, child);\n        if (node_1)\n            return node_1;\n    }\n    return null;\n}\n/**\n * @template T\n * @param {?} value\n * @param {?} node\n * @return {?}\n */\nfunction findPath(value, node) {\n    if (value === node.value)\n        return [node];\n    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n        var child = _a[_i];\n        /** @type {?} */\n        var path = findPath(value, child);\n        if (path.length) {\n            path.unshift(node);\n            return path;\n        }\n    }\n    return [];\n}\n/**\n * @template T\n */\nvar /**\n * @template T\n */\nTreeNode = /** @class */ (function () {\n    function TreeNode(value, children) {\n        this.value = value;\n        this.children = children;\n    }\n    /**\n     * @return {?}\n     */\n    TreeNode.prototype.toString = /**\n     * @return {?}\n     */\n    function () { return \"TreeNode(\" + this.value + \")\"; };\n    return TreeNode;\n}());\n/**\n * @template T\n */\nexport { TreeNode };\nif (false) {\n    /** @type {?} */\n    TreeNode.prototype.value;\n    /** @type {?} */\n    TreeNode.prototype.children;\n}\n/**\n * @template T\n * @param {?} node\n * @return {?}\n */\nexport function nodeChildrenAsMap(node) {\n    /** @type {?} */\n    var map = {};\n    if (node) {\n        node.children.forEach(function (child) { return map[child.value.outlet] = child; });\n    }\n    return map;\n}\n//# sourceMappingURL=tree.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as tslib_1 from \"tslib\";\nimport { BehaviorSubject } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { PRIMARY_OUTLET, convertToParamMap } from './shared';\nimport { UrlSegment, equalSegments } from './url_tree';\nimport { shallowEqual, shallowEqualArrays } from './utils/collection';\nimport { Tree, TreeNode } from './utils/tree';\n/**\n * \\@description\n *\n * Represents the state of the router.\n *\n * RouterState is a tree of activated routes. Every node in this tree knows about the \"consumed\" URL\n * segments, the extracted parameters, and the resolved data.\n *\n * ### Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * See `ActivatedRoute` for more information.\n *\n *\n */\nvar /**\n * \\@description\n *\n * Represents the state of the router.\n *\n * RouterState is a tree of activated routes. Every node in this tree knows about the \"consumed\" URL\n * segments, the extracted parameters, and the resolved data.\n *\n * ### Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * See `ActivatedRoute` for more information.\n *\n *\n */\nRouterState = /** @class */ (function (_super) {\n    tslib_1.__extends(RouterState, _super);\n    /** @internal */\n    function RouterState(root, snapshot) {\n        var _this = _super.call(this, root) || this;\n        _this.snapshot = snapshot;\n        setRouterState(/** @type {?} */ (_this), root);\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    RouterState.prototype.toString = /**\n     * @return {?}\n     */\n    function () { return this.snapshot.toString(); };\n    return RouterState;\n}(Tree));\n/**\n * \\@description\n *\n * Represents the state of the router.\n *\n * RouterState is a tree of activated routes. Every node in this tree knows about the \"consumed\" URL\n * segments, the extracted parameters, and the resolved data.\n *\n * ### Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * See `ActivatedRoute` for more information.\n *\n *\n */\nexport { RouterState };\nif (false) {\n    /**\n     * The current snapshot of the router state\n     * @type {?}\n     */\n    RouterState.prototype.snapshot;\n}\n/**\n * @param {?} urlTree\n * @param {?} rootComponent\n * @return {?}\n */\nexport function createEmptyState(urlTree, rootComponent) {\n    /** @type {?} */\n    var snapshot = createEmptyStateSnapshot(urlTree, rootComponent);\n    /** @type {?} */\n    var emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);\n    /** @type {?} */\n    var emptyParams = new BehaviorSubject({});\n    /** @type {?} */\n    var emptyData = new BehaviorSubject({});\n    /** @type {?} */\n    var emptyQueryParams = new BehaviorSubject({});\n    /** @type {?} */\n    var fragment = new BehaviorSubject('');\n    /** @type {?} */\n    var activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\n    activated.snapshot = snapshot.root;\n    return new RouterState(new TreeNode(activated, []), snapshot);\n}\n/**\n * @param {?} urlTree\n * @param {?} rootComponent\n * @return {?}\n */\nexport function createEmptyStateSnapshot(urlTree, rootComponent) {\n    /** @type {?} */\n    var emptyParams = {};\n    /** @type {?} */\n    var emptyData = {};\n    /** @type {?} */\n    var emptyQueryParams = {};\n    /** @type {?} */\n    var fragment = '';\n    /** @type {?} */\n    var activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});\n    return new RouterStateSnapshot('', new TreeNode(activated, []));\n}\n/**\n * \\@description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet.  An `ActivatedRoute` can also be used to traverse the router state tree.\n *\n * ```\n * \\@Component({...})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: Observable<string> = route.params.map(p => p.id);\n *     const url: Observable<string> = route.url.map(segments => segments.join(''));\n *     // route.data includes both `data` and `resolve`\n *     const user = route.data.map(d => d.user);\n *   }\n * }\n * ```\n *\n *\n */\nvar /**\n * \\@description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet.  An `ActivatedRoute` can also be used to traverse the router state tree.\n *\n * ```\n * \\@Component({...})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: Observable<string> = route.params.map(p => p.id);\n *     const url: Observable<string> = route.url.map(segments => segments.join(''));\n *     // route.data includes both `data` and `resolve`\n *     const user = route.data.map(d => d.user);\n *   }\n * }\n * ```\n *\n *\n */\nActivatedRoute = /** @class */ (function () {\n    /** @internal */\n    function ActivatedRoute(url, params, queryParams, fragment, data, outlet, component, futureSnapshot) {\n        this.url = url;\n        this.params = params;\n        this.queryParams = queryParams;\n        this.fragment = fragment;\n        this.data = data;\n        this.outlet = outlet;\n        this.component = component;\n        this._futureSnapshot = futureSnapshot;\n    }\n    Object.defineProperty(ActivatedRoute.prototype, \"routeConfig\", {\n        /** The configuration used to match this route */\n        get: /**\n         * The configuration used to match this route\n         * @return {?}\n         */\n        function () { return this._futureSnapshot.routeConfig; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"root\", {\n        /** The root of the router state */\n        get: /**\n         * The root of the router state\n         * @return {?}\n         */\n        function () { return this._routerState.root; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"parent\", {\n        /** The parent of this route in the router state tree */\n        get: /**\n         * The parent of this route in the router state tree\n         * @return {?}\n         */\n        function () { return this._routerState.parent(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"firstChild\", {\n        /** The first child of this route in the router state tree */\n        get: /**\n         * The first child of this route in the router state tree\n         * @return {?}\n         */\n        function () { return this._routerState.firstChild(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"children\", {\n        /** The children of this route in the router state tree */\n        get: /**\n         * The children of this route in the router state tree\n         * @return {?}\n         */\n        function () { return this._routerState.children(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"pathFromRoot\", {\n        /** The path from the root of the router state tree to this route */\n        get: /**\n         * The path from the root of the router state tree to this route\n         * @return {?}\n         */\n        function () { return this._routerState.pathFromRoot(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"paramMap\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this._paramMap) {\n                this._paramMap = this.params.pipe(map(function (p) { return convertToParamMap(p); }));\n            }\n            return this._paramMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"queryParamMap\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this._queryParamMap) {\n                this._queryParamMap =\n                    this.queryParams.pipe(map(function (p) { return convertToParamMap(p); }));\n            }\n            return this._queryParamMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    ActivatedRoute.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        return this.snapshot ? this.snapshot.toString() : \"Future(\" + this._futureSnapshot + \")\";\n    };\n    return ActivatedRoute;\n}());\n/**\n * \\@description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet.  An `ActivatedRoute` can also be used to traverse the router state tree.\n *\n * ```\n * \\@Component({...})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: Observable<string> = route.params.map(p => p.id);\n *     const url: Observable<string> = route.url.map(segments => segments.join(''));\n *     // route.data includes both `data` and `resolve`\n *     const user = route.data.map(d => d.user);\n *   }\n * }\n * ```\n *\n *\n */\nexport { ActivatedRoute };\nif (false) {\n    /**\n     * The current snapshot of this route\n     * @type {?}\n     */\n    ActivatedRoute.prototype.snapshot;\n    /**\n     * \\@internal\n     * @type {?}\n     */\n    ActivatedRoute.prototype._futureSnapshot;\n    /**\n     * \\@internal\n     * @type {?}\n     */\n    ActivatedRoute.prototype._routerState;\n    /**\n     * \\@internal\n     * @type {?}\n     */\n    ActivatedRoute.prototype._paramMap;\n    /**\n     * \\@internal\n     * @type {?}\n     */\n    ActivatedRoute.prototype._queryParamMap;\n    /**\n     * An observable of the URL segments matched by this route\n     * @type {?}\n     */\n    ActivatedRoute.prototype.url;\n    /**\n     * An observable of the matrix parameters scoped to this route\n     * @type {?}\n     */\n    ActivatedRoute.prototype.params;\n    /**\n     * An observable of the query parameters shared by all the routes\n     * @type {?}\n     */\n    ActivatedRoute.prototype.queryParams;\n    /**\n     * An observable of the URL fragment shared by all the routes\n     * @type {?}\n     */\n    ActivatedRoute.prototype.fragment;\n    /**\n     * An observable of the static and resolved data of this route.\n     * @type {?}\n     */\n    ActivatedRoute.prototype.data;\n    /**\n     * The outlet name of the route. It's a constant\n     * @type {?}\n     */\n    ActivatedRoute.prototype.outlet;\n    /**\n     * The component of the route. It's a constant\n     * @type {?}\n     */\n    ActivatedRoute.prototype.component;\n}\n/** @typedef {?} */\nvar ParamsInheritanceStrategy;\nexport { ParamsInheritanceStrategy };\n/** @typedef {?} */\nvar Inherited;\nexport { Inherited };\n/**\n * Returns the inherited params, data, and resolve for a given route.\n * By default, this only inherits values up to the nearest path-less or component-less route.\n * \\@internal\n * @param {?} route\n * @param {?=} paramsInheritanceStrategy\n * @return {?}\n */\nexport function inheritedParamsDataResolve(route, paramsInheritanceStrategy) {\n    if (paramsInheritanceStrategy === void 0) { paramsInheritanceStrategy = 'emptyOnly'; }\n    /** @type {?} */\n    var pathFromRoot = route.pathFromRoot;\n    /** @type {?} */\n    var inheritingStartingFrom = 0;\n    if (paramsInheritanceStrategy !== 'always') {\n        inheritingStartingFrom = pathFromRoot.length - 1;\n        while (inheritingStartingFrom >= 1) {\n            /** @type {?} */\n            var current = pathFromRoot[inheritingStartingFrom];\n            /** @type {?} */\n            var parent_1 = pathFromRoot[inheritingStartingFrom - 1];\n            // current route is an empty path => inherits its parent's params and data\n            if (current.routeConfig && current.routeConfig.path === '') {\n                inheritingStartingFrom--;\n                // parent is componentless => current route should inherit its params and data\n            }\n            else if (!parent_1.component) {\n                inheritingStartingFrom--;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    return flattenInherited(pathFromRoot.slice(inheritingStartingFrom));\n}\n/**\n * \\@internal\n * @param {?} pathFromRoot\n * @return {?}\n */\nfunction flattenInherited(pathFromRoot) {\n    return pathFromRoot.reduce(function (res, curr) {\n        /** @type {?} */\n        var params = tslib_1.__assign({}, res.params, curr.params);\n        /** @type {?} */\n        var data = tslib_1.__assign({}, res.data, curr.data);\n        /** @type {?} */\n        var resolve = tslib_1.__assign({}, res.resolve, curr._resolvedData);\n        return { params: params, data: data, resolve: resolve };\n    }, /** @type {?} */ ({ params: {}, data: {}, resolve: {} }));\n}\n/**\n * \\@description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\n * traverse the router state tree.\n *\n * ```\n * \\@Component({templateUrl:'./my-component.html'})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: string = route.snapshot.params.id;\n *     const url: string = route.snapshot.url.join('');\n *     const user = route.snapshot.data.user;\n *   }\n * }\n * ```\n *\n *\n */\nvar /**\n * \\@description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\n * traverse the router state tree.\n *\n * ```\n * \\@Component({templateUrl:'./my-component.html'})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: string = route.snapshot.params.id;\n *     const url: string = route.snapshot.url.join('');\n *     const user = route.snapshot.data.user;\n *   }\n * }\n * ```\n *\n *\n */\nActivatedRouteSnapshot = /** @class */ (function () {\n    /** @internal */\n    function ActivatedRouteSnapshot(url, params, queryParams, fragment, data, outlet, component, routeConfig, urlSegment, lastPathIndex, resolve) {\n        this.url = url;\n        this.params = params;\n        this.queryParams = queryParams;\n        this.fragment = fragment;\n        this.data = data;\n        this.outlet = outlet;\n        this.component = component;\n        this.routeConfig = routeConfig;\n        this._urlSegment = urlSegment;\n        this._lastPathIndex = lastPathIndex;\n        this._resolve = resolve;\n    }\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"root\", {\n        /** The root of the router state */\n        get: /**\n         * The root of the router state\n         * @return {?}\n         */\n        function () { return this._routerState.root; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"parent\", {\n        /** The parent of this route in the router state tree */\n        get: /**\n         * The parent of this route in the router state tree\n         * @return {?}\n         */\n        function () { return this._routerState.parent(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"firstChild\", {\n        /** The first child of this route in the router state tree */\n        get: /**\n         * The first child of this route in the router state tree\n         * @return {?}\n         */\n        function () { return this._routerState.firstChild(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"children\", {\n        /** The children of this route in the router state tree */\n        get: /**\n         * The children of this route in the router state tree\n         * @return {?}\n         */\n        function () { return this._routerState.children(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"pathFromRoot\", {\n        /** The path from the root of the router state tree to this route */\n        get: /**\n         * The path from the root of the router state tree to this route\n         * @return {?}\n         */\n        function () { return this._routerState.pathFromRoot(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"paramMap\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this._paramMap) {\n                this._paramMap = convertToParamMap(this.params);\n            }\n            return this._paramMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"queryParamMap\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this._queryParamMap) {\n                this._queryParamMap = convertToParamMap(this.queryParams);\n            }\n            return this._queryParamMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    ActivatedRouteSnapshot.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var url = this.url.map(function (segment) { return segment.toString(); }).join('/');\n        /** @type {?} */\n        var matched = this.routeConfig ? this.routeConfig.path : '';\n        return \"Route(url:'\" + url + \"', path:'\" + matched + \"')\";\n    };\n    return ActivatedRouteSnapshot;\n}());\n/**\n * \\@description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\n * traverse the router state tree.\n *\n * ```\n * \\@Component({templateUrl:'./my-component.html'})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: string = route.snapshot.params.id;\n *     const url: string = route.snapshot.url.join('');\n *     const user = route.snapshot.data.user;\n *   }\n * }\n * ```\n *\n *\n */\nexport { ActivatedRouteSnapshot };\nif (false) {\n    /**\n     * The configuration used to match this route *\n     * @type {?}\n     */\n    ActivatedRouteSnapshot.prototype.routeConfig;\n    /**\n     * \\@internal *\n     * @type {?}\n     */\n    ActivatedRouteSnapshot.prototype._urlSegment;\n    /**\n     * \\@internal\n     * @type {?}\n     */\n    ActivatedRouteSnapshot.prototype._lastPathIndex;\n    /**\n     * \\@internal\n     * @type {?}\n     */\n    ActivatedRouteSnapshot.prototype._resolve;\n    /**\n     * \\@internal\n     * @type {?}\n     */\n    ActivatedRouteSnapshot.prototype._resolvedData;\n    /**\n     * \\@internal\n     * @type {?}\n     */\n    ActivatedRouteSnapshot.prototype._routerState;\n    /**\n     * \\@internal\n     * @type {?}\n     */\n    ActivatedRouteSnapshot.prototype._paramMap;\n    /**\n     * \\@internal\n     * @type {?}\n     */\n    ActivatedRouteSnapshot.prototype._queryParamMap;\n    /**\n     * The URL segments matched by this route\n     * @type {?}\n     */\n    ActivatedRouteSnapshot.prototype.url;\n    /**\n     * The matrix parameters scoped to this route\n     * @type {?}\n     */\n    ActivatedRouteSnapshot.prototype.params;\n    /**\n     * The query parameters shared by all the routes\n     * @type {?}\n     */\n    ActivatedRouteSnapshot.prototype.queryParams;\n    /**\n     * The URL fragment shared by all the routes\n     * @type {?}\n     */\n    ActivatedRouteSnapshot.prototype.fragment;\n    /**\n     * The static and resolved data of this route\n     * @type {?}\n     */\n    ActivatedRouteSnapshot.prototype.data;\n    /**\n     * The outlet name of the route\n     * @type {?}\n     */\n    ActivatedRouteSnapshot.prototype.outlet;\n    /**\n     * The component of the route\n     * @type {?}\n     */\n    ActivatedRouteSnapshot.prototype.component;\n}\n/**\n * \\@description\n *\n * Represents the state of the router at a moment in time.\n *\n * This is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * ### Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n *\n */\nvar /**\n * \\@description\n *\n * Represents the state of the router at a moment in time.\n *\n * This is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * ### Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n *\n */\nRouterStateSnapshot = /** @class */ (function (_super) {\n    tslib_1.__extends(RouterStateSnapshot, _super);\n    /** @internal */\n    function RouterStateSnapshot(url, root) {\n        var _this = _super.call(this, root) || this;\n        _this.url = url;\n        setRouterState(/** @type {?} */ (_this), root);\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    RouterStateSnapshot.prototype.toString = /**\n     * @return {?}\n     */\n    function () { return serializeNode(this._root); };\n    return RouterStateSnapshot;\n}(Tree));\n/**\n * \\@description\n *\n * Represents the state of the router at a moment in time.\n *\n * This is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * ### Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n *\n */\nexport { RouterStateSnapshot };\nif (false) {\n    /**\n     * The url from which this snapshot was created\n     * @type {?}\n     */\n    RouterStateSnapshot.prototype.url;\n}\n/**\n * @template U, T\n * @param {?} state\n * @param {?} node\n * @return {?}\n */\nfunction setRouterState(state, node) {\n    node.value._routerState = state;\n    node.children.forEach(function (c) { return setRouterState(state, c); });\n}\n/**\n * @param {?} node\n * @return {?}\n */\nfunction serializeNode(node) {\n    /** @type {?} */\n    var c = node.children.length > 0 ? \" { \" + node.children.map(serializeNode).join(', ') + \" } \" : '';\n    return \"\" + node.value + c;\n}\n/**\n * The expectation is that the activate route is created with the right set of parameters.\n * So we push new values into the observables only when they are not the initial values.\n * And we detect that by checking if the snapshot field is set.\n * @param {?} route\n * @return {?}\n */\nexport function advanceActivatedRoute(route) {\n    if (route.snapshot) {\n        /** @type {?} */\n        var currentSnapshot = route.snapshot;\n        /** @type {?} */\n        var nextSnapshot = route._futureSnapshot;\n        route.snapshot = nextSnapshot;\n        if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\n            (/** @type {?} */ (route.queryParams)).next(nextSnapshot.queryParams);\n        }\n        if (currentSnapshot.fragment !== nextSnapshot.fragment) {\n            (/** @type {?} */ (route.fragment)).next(nextSnapshot.fragment);\n        }\n        if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\n            (/** @type {?} */ (route.params)).next(nextSnapshot.params);\n        }\n        if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\n            (/** @type {?} */ (route.url)).next(nextSnapshot.url);\n        }\n        if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\n            (/** @type {?} */ (route.data)).next(nextSnapshot.data);\n        }\n    }\n    else {\n        route.snapshot = route._futureSnapshot;\n        // this is for resolved data\n        (/** @type {?} */ (route.data)).next(route._futureSnapshot.data);\n    }\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nexport function equalParamsAndUrlSegments(a, b) {\n    /** @type {?} */\n    var equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n    /** @type {?} */\n    var parentsMismatch = !a.parent !== !b.parent;\n    return equalUrlParams && !parentsMismatch &&\n        (!a.parent || equalParamsAndUrlSegments(a.parent, /** @type {?} */ ((b.parent))));\n}\n//# sourceMappingURL=router_state.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { BehaviorSubject } from 'rxjs';\nimport { ActivatedRoute, RouterState } from './router_state';\nimport { TreeNode } from './utils/tree';\n/**\n * @param {?} routeReuseStrategy\n * @param {?} curr\n * @param {?} prevState\n * @return {?}\n */\nexport function createRouterState(routeReuseStrategy, curr, prevState) {\n    /** @type {?} */\n    var root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n    return new RouterState(root, curr);\n}\n/**\n * @param {?} routeReuseStrategy\n * @param {?} curr\n * @param {?=} prevState\n * @return {?}\n */\nfunction createNode(routeReuseStrategy, curr, prevState) {\n    // reuse an activated route that is currently displayed on the screen\n    if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n        /** @type {?} */\n        var value = prevState.value;\n        value._futureSnapshot = curr.value;\n        /** @type {?} */\n        var children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n        return new TreeNode(value, children);\n        // retrieve an activated route that is used to be displayed, but is not currently displayed\n    }\n    else {\n        /** @type {?} */\n        var detachedRouteHandle = /** @type {?} */ (routeReuseStrategy.retrieve(curr.value));\n        if (detachedRouteHandle) {\n            /** @type {?} */\n            var tree = detachedRouteHandle.route;\n            setFutureSnapshotsOfActivatedRoutes(curr, tree);\n            return tree;\n        }\n        else {\n            /** @type {?} */\n            var value = createActivatedRoute(curr.value);\n            /** @type {?} */\n            var children = curr.children.map(function (c) { return createNode(routeReuseStrategy, c); });\n            return new TreeNode(value, children);\n        }\n    }\n}\n/**\n * @param {?} curr\n * @param {?} result\n * @return {?}\n */\nfunction setFutureSnapshotsOfActivatedRoutes(curr, result) {\n    if (curr.value.routeConfig !== result.value.routeConfig) {\n        throw new Error('Cannot reattach ActivatedRouteSnapshot created from a different route');\n    }\n    if (curr.children.length !== result.children.length) {\n        throw new Error('Cannot reattach ActivatedRouteSnapshot with a different number of children');\n    }\n    result.value._futureSnapshot = curr.value;\n    for (var i = 0; i < curr.children.length; ++i) {\n        setFutureSnapshotsOfActivatedRoutes(curr.children[i], result.children[i]);\n    }\n}\n/**\n * @param {?} routeReuseStrategy\n * @param {?} curr\n * @param {?} prevState\n * @return {?}\n */\nfunction createOrReuseChildren(routeReuseStrategy, curr, prevState) {\n    return curr.children.map(function (child) {\n        for (var _i = 0, _a = prevState.children; _i < _a.length; _i++) {\n            var p = _a[_i];\n            if (routeReuseStrategy.shouldReuseRoute(p.value.snapshot, child.value)) {\n                return createNode(routeReuseStrategy, child, p);\n            }\n        }\n        return createNode(routeReuseStrategy, child);\n    });\n}\n/**\n * @param {?} c\n * @return {?}\n */\nfunction createActivatedRoute(c) {\n    return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);\n}\n//# sourceMappingURL=create_router_state.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { PRIMARY_OUTLET } from './shared';\nimport { UrlSegment, UrlSegmentGroup, UrlTree } from './url_tree';\nimport { forEach, last, shallowEqual } from './utils/collection';\n/**\n * @param {?} route\n * @param {?} urlTree\n * @param {?} commands\n * @param {?} queryParams\n * @param {?} fragment\n * @return {?}\n */\nexport function createUrlTree(route, urlTree, commands, queryParams, fragment) {\n    if (commands.length === 0) {\n        return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);\n    }\n    /** @type {?} */\n    var nav = computeNavigation(commands);\n    if (nav.toRoot()) {\n        return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);\n    }\n    /** @type {?} */\n    var startingPosition = findStartingPosition(nav, urlTree, route);\n    /** @type {?} */\n    var segmentGroup = startingPosition.processChildren ?\n        updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) :\n        updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);\n    return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);\n}\n/**\n * @param {?} command\n * @return {?}\n */\nfunction isMatrixParams(command) {\n    return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n}\n/**\n * @param {?} oldSegmentGroup\n * @param {?} newSegmentGroup\n * @param {?} urlTree\n * @param {?} queryParams\n * @param {?} fragment\n * @return {?}\n */\nfunction tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {\n    /** @type {?} */\n    var qp = {};\n    if (queryParams) {\n        forEach(queryParams, function (value, name) {\n            qp[name] = Array.isArray(value) ? value.map(function (v) { return \"\" + v; }) : \"\" + value;\n        });\n    }\n    if (urlTree.root === oldSegmentGroup) {\n        return new UrlTree(newSegmentGroup, qp, fragment);\n    }\n    return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), qp, fragment);\n}\n/**\n * @param {?} current\n * @param {?} oldSegment\n * @param {?} newSegment\n * @return {?}\n */\nfunction replaceSegment(current, oldSegment, newSegment) {\n    /** @type {?} */\n    var children = {};\n    forEach(current.children, function (c, outletName) {\n        if (c === oldSegment) {\n            children[outletName] = newSegment;\n        }\n        else {\n            children[outletName] = replaceSegment(c, oldSegment, newSegment);\n        }\n    });\n    return new UrlSegmentGroup(current.segments, children);\n}\nvar Navigation = /** @class */ (function () {\n    function Navigation(isAbsolute, numberOfDoubleDots, commands) {\n        this.isAbsolute = isAbsolute;\n        this.numberOfDoubleDots = numberOfDoubleDots;\n        this.commands = commands;\n        if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n            throw new Error('Root segment cannot have matrix parameters');\n        }\n        /** @type {?} */\n        var cmdWithOutlet = commands.find(function (c) { return typeof c === 'object' && c != null && c.outlets; });\n        if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {\n            throw new Error('{outlets:{}} has to be the last command');\n        }\n    }\n    /**\n     * @return {?}\n     */\n    Navigation.prototype.toRoot = /**\n     * @return {?}\n     */\n    function () {\n        return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n    };\n    return Navigation;\n}());\nif (false) {\n    /** @type {?} */\n    Navigation.prototype.isAbsolute;\n    /** @type {?} */\n    Navigation.prototype.numberOfDoubleDots;\n    /** @type {?} */\n    Navigation.prototype.commands;\n}\n/**\n * Transforms commands to a normalized `Navigation`\n * @param {?} commands\n * @return {?}\n */\nfunction computeNavigation(commands) {\n    if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] === '/') {\n        return new Navigation(true, 0, commands);\n    }\n    /** @type {?} */\n    var numberOfDoubleDots = 0;\n    /** @type {?} */\n    var isAbsolute = false;\n    /** @type {?} */\n    var res = commands.reduce(function (res, cmd, cmdIdx) {\n        if (typeof cmd === 'object' && cmd != null) {\n            if (cmd.outlets) {\n                /** @type {?} */\n                var outlets_1 = {};\n                forEach(cmd.outlets, function (commands, name) {\n                    outlets_1[name] = typeof commands === 'string' ? commands.split('/') : commands;\n                });\n                return res.concat([{ outlets: outlets_1 }]);\n            }\n            if (cmd.segmentPath) {\n                return res.concat([cmd.segmentPath]);\n            }\n        }\n        if (!(typeof cmd === 'string')) {\n            return res.concat([cmd]);\n        }\n        if (cmdIdx === 0) {\n            cmd.split('/').forEach(function (urlPart, partIndex) {\n                if (partIndex == 0 && urlPart === '.') {\n                    // skip './a'\n                }\n                else if (partIndex == 0 && urlPart === '') { //  '/a'\n                    //  '/a'\n                    isAbsolute = true;\n                }\n                else if (urlPart === '..') { //  '../a'\n                    //  '../a'\n                    numberOfDoubleDots++;\n                }\n                else if (urlPart != '') {\n                    res.push(urlPart);\n                }\n            });\n            return res;\n        }\n        return res.concat([cmd]);\n    }, []);\n    return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\nvar Position = /** @class */ (function () {\n    function Position(segmentGroup, processChildren, index) {\n        this.segmentGroup = segmentGroup;\n        this.processChildren = processChildren;\n        this.index = index;\n    }\n    return Position;\n}());\nif (false) {\n    /** @type {?} */\n    Position.prototype.segmentGroup;\n    /** @type {?} */\n    Position.prototype.processChildren;\n    /** @type {?} */\n    Position.prototype.index;\n}\n/**\n * @param {?} nav\n * @param {?} tree\n * @param {?} route\n * @return {?}\n */\nfunction findStartingPosition(nav, tree, route) {\n    if (nav.isAbsolute) {\n        return new Position(tree.root, true, 0);\n    }\n    if (route.snapshot._lastPathIndex === -1) {\n        return new Position(route.snapshot._urlSegment, true, 0);\n    }\n    /** @type {?} */\n    var modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n    /** @type {?} */\n    var index = route.snapshot._lastPathIndex + modifier;\n    return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, nav.numberOfDoubleDots);\n}\n/**\n * @param {?} group\n * @param {?} index\n * @param {?} numberOfDoubleDots\n * @return {?}\n */\nfunction createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\n    /** @type {?} */\n    var g = group;\n    /** @type {?} */\n    var ci = index;\n    /** @type {?} */\n    var dd = numberOfDoubleDots;\n    while (dd > ci) {\n        dd -= ci;\n        g = /** @type {?} */ ((g.parent));\n        if (!g) {\n            throw new Error('Invalid number of \\'../\\'');\n        }\n        ci = g.segments.length;\n    }\n    return new Position(g, false, ci - dd);\n}\n/**\n * @param {?} command\n * @return {?}\n */\nfunction getPath(command) {\n    if (typeof command === 'object' && command != null && command.outlets) {\n        return command.outlets[PRIMARY_OUTLET];\n    }\n    return \"\" + command;\n}\n/**\n * @param {?} commands\n * @return {?}\n */\nfunction getOutlets(commands) {\n    var _a, _b;\n    if (!(typeof commands[0] === 'object'))\n        return _a = {}, _a[PRIMARY_OUTLET] = commands, _a;\n    if (commands[0].outlets === undefined)\n        return _b = {}, _b[PRIMARY_OUTLET] = commands, _b;\n    return commands[0].outlets;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\nfunction updateSegmentGroup(segmentGroup, startIndex, commands) {\n    if (!segmentGroup) {\n        segmentGroup = new UrlSegmentGroup([], {});\n    }\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n        return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n    }\n    /** @type {?} */\n    var m = prefixedWith(segmentGroup, startIndex, commands);\n    /** @type {?} */\n    var slicedCommands = commands.slice(m.commandIndex);\n    if (m.match && m.pathIndex < segmentGroup.segments.length) {\n        /** @type {?} */\n        var g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n        g.children[PRIMARY_OUTLET] =\n            new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n        return updateSegmentGroupChildren(g, 0, slicedCommands);\n    }\n    else if (m.match && slicedCommands.length === 0) {\n        return new UrlSegmentGroup(segmentGroup.segments, {});\n    }\n    else if (m.match && !segmentGroup.hasChildren()) {\n        return createNewSegmentGroup(segmentGroup, startIndex, commands);\n    }\n    else if (m.match) {\n        return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n    }\n    else {\n        return createNewSegmentGroup(segmentGroup, startIndex, commands);\n    }\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\nfunction updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\n    if (commands.length === 0) {\n        return new UrlSegmentGroup(segmentGroup.segments, {});\n    }\n    else {\n        /** @type {?} */\n        var outlets_2 = getOutlets(commands);\n        /** @type {?} */\n        var children_1 = {};\n        forEach(outlets_2, function (commands, outlet) {\n            if (commands !== null) {\n                children_1[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n            }\n        });\n        forEach(segmentGroup.children, function (child, childOutlet) {\n            if (outlets_2[childOutlet] === undefined) {\n                children_1[childOutlet] = child;\n            }\n        });\n        return new UrlSegmentGroup(segmentGroup.segments, children_1);\n    }\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\nfunction prefixedWith(segmentGroup, startIndex, commands) {\n    /** @type {?} */\n    var currentCommandIndex = 0;\n    /** @type {?} */\n    var currentPathIndex = startIndex;\n    /** @type {?} */\n    var noMatch = { match: false, pathIndex: 0, commandIndex: 0 };\n    while (currentPathIndex < segmentGroup.segments.length) {\n        if (currentCommandIndex >= commands.length)\n            return noMatch;\n        /** @type {?} */\n        var path = segmentGroup.segments[currentPathIndex];\n        /** @type {?} */\n        var curr = getPath(commands[currentCommandIndex]);\n        /** @type {?} */\n        var next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n        if (currentPathIndex > 0 && curr === undefined)\n            break;\n        if (curr && next && (typeof next === 'object') && next.outlets === undefined) {\n            if (!compare(curr, next, path))\n                return noMatch;\n            currentCommandIndex += 2;\n        }\n        else {\n            if (!compare(curr, {}, path))\n                return noMatch;\n            currentCommandIndex++;\n        }\n        currentPathIndex++;\n    }\n    return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\nfunction createNewSegmentGroup(segmentGroup, startIndex, commands) {\n    /** @type {?} */\n    var paths = segmentGroup.segments.slice(0, startIndex);\n    /** @type {?} */\n    var i = 0;\n    while (i < commands.length) {\n        if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {\n            /** @type {?} */\n            var children = createNewSegmentChildren(commands[i].outlets);\n            return new UrlSegmentGroup(paths, children);\n        }\n        // if we start with an object literal, we need to reuse the path part from the segment\n        if (i === 0 && isMatrixParams(commands[0])) {\n            /** @type {?} */\n            var p = segmentGroup.segments[startIndex];\n            paths.push(new UrlSegment(p.path, commands[0]));\n            i++;\n            continue;\n        }\n        /** @type {?} */\n        var curr = getPath(commands[i]);\n        /** @type {?} */\n        var next = (i < commands.length - 1) ? commands[i + 1] : null;\n        if (curr && next && isMatrixParams(next)) {\n            paths.push(new UrlSegment(curr, stringify(next)));\n            i += 2;\n        }\n        else {\n            paths.push(new UrlSegment(curr, {}));\n            i++;\n        }\n    }\n    return new UrlSegmentGroup(paths, {});\n}\n/**\n * @param {?} outlets\n * @return {?}\n */\nfunction createNewSegmentChildren(outlets) {\n    /** @type {?} */\n    var children = {};\n    forEach(outlets, function (commands, outlet) {\n        if (commands !== null) {\n            children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n        }\n    });\n    return children;\n}\n/**\n * @param {?} params\n * @return {?}\n */\nfunction stringify(params) {\n    /** @type {?} */\n    var res = {};\n    forEach(params, function (v, k) { return res[k] = \"\" + v; });\n    return res;\n}\n/**\n * @param {?} path\n * @param {?} params\n * @param {?} segment\n * @return {?}\n */\nfunction compare(path, params, segment) {\n    return path == segment.path && shallowEqual(params, segment.parameters);\n}\n//# sourceMappingURL=create_url_tree.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as tslib_1 from \"tslib\";\nimport { from, of } from 'rxjs';\nimport { concatMap, every, first, last, map, mergeMap, reduce } from 'rxjs/operators';\nimport { ActivationStart, ChildActivationStart } from './events';\nimport { equalParamsAndUrlSegments, inheritedParamsDataResolve } from './router_state';\nimport { andObservables, forEach, shallowEqual, wrapIntoObservable } from './utils/collection';\nimport { nodeChildrenAsMap } from './utils/tree';\nvar CanActivate = /** @class */ (function () {\n    function CanActivate(path) {\n        this.path = path;\n        this.route = this.path[this.path.length - 1];\n    }\n    return CanActivate;\n}());\nif (false) {\n    /** @type {?} */\n    CanActivate.prototype.route;\n    /** @type {?} */\n    CanActivate.prototype.path;\n}\nvar CanDeactivate = /** @class */ (function () {\n    function CanDeactivate(component, route) {\n        this.component = component;\n        this.route = route;\n    }\n    return CanDeactivate;\n}());\nif (false) {\n    /** @type {?} */\n    CanDeactivate.prototype.component;\n    /** @type {?} */\n    CanDeactivate.prototype.route;\n}\n/**\n * This class bundles the actions involved in preactivation of a route.\n */\nvar /**\n * This class bundles the actions involved in preactivation of a route.\n */\nPreActivation = /** @class */ (function () {\n    function PreActivation(future, curr, moduleInjector, forwardEvent) {\n        this.future = future;\n        this.curr = curr;\n        this.moduleInjector = moduleInjector;\n        this.forwardEvent = forwardEvent;\n        this.canActivateChecks = [];\n        this.canDeactivateChecks = [];\n    }\n    /**\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    PreActivation.prototype.initialize = /**\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    function (parentContexts) {\n        /** @type {?} */\n        var futureRoot = this.future._root;\n        /** @type {?} */\n        var currRoot = this.curr ? this.curr._root : null;\n        this.setupChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n    };\n    /**\n     * @return {?}\n     */\n    PreActivation.prototype.checkGuards = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this.isDeactivating() && !this.isActivating()) {\n            return of(true);\n        }\n        /** @type {?} */\n        var canDeactivate$ = this.runCanDeactivateChecks();\n        return canDeactivate$.pipe(mergeMap(function (canDeactivate) { return canDeactivate ? _this.runCanActivateChecks() : of(false); }));\n    };\n    /**\n     * @param {?} paramsInheritanceStrategy\n     * @return {?}\n     */\n    PreActivation.prototype.resolveData = /**\n     * @param {?} paramsInheritanceStrategy\n     * @return {?}\n     */\n    function (paramsInheritanceStrategy) {\n        var _this = this;\n        if (!this.isActivating())\n            return of(null);\n        return from(this.canActivateChecks)\n            .pipe(concatMap(function (check) { return _this.runResolve(check.route, paramsInheritanceStrategy); }), reduce(function (_, __) { return _; }));\n    };\n    /**\n     * @return {?}\n     */\n    PreActivation.prototype.isDeactivating = /**\n     * @return {?}\n     */\n    function () { return this.canDeactivateChecks.length !== 0; };\n    /**\n     * @return {?}\n     */\n    PreActivation.prototype.isActivating = /**\n     * @return {?}\n     */\n    function () { return this.canActivateChecks.length !== 0; };\n    /**\n     * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n     * proper state to run `checkGuards()` method.\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @param {?} futurePath\n     * @return {?}\n     */\n    PreActivation.prototype.setupChildRouteGuards = /**\n     * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n     * proper state to run `checkGuards()` method.\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @param {?} futurePath\n     * @return {?}\n     */\n    function (futureNode, currNode, contexts, futurePath) {\n        var _this = this;\n        /** @type {?} */\n        var prevChildren = nodeChildrenAsMap(currNode);\n        // Process the children of the future route\n        futureNode.children.forEach(function (c) {\n            _this.setupRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]));\n            delete prevChildren[c.value.outlet];\n        });\n        // Process any children left from the current route (not active for the future route)\n        forEach(prevChildren, function (v, k) {\n            return _this.deactivateRouteAndItsChildren(v, /** @type {?} */ ((contexts)).getContext(k));\n        });\n    };\n    /**\n     * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n     * proper state to run `checkGuards()` method.\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContexts\n     * @param {?} futurePath\n     * @return {?}\n     */\n    PreActivation.prototype.setupRouteGuards = /**\n     * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n     * proper state to run `checkGuards()` method.\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContexts\n     * @param {?} futurePath\n     * @return {?}\n     */\n    function (futureNode, currNode, parentContexts, futurePath) {\n        /** @type {?} */\n        var future = futureNode.value;\n        /** @type {?} */\n        var curr = currNode ? currNode.value : null;\n        /** @type {?} */\n        var context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\n        // reusing the node\n        if (curr && future.routeConfig === curr.routeConfig) {\n            /** @type {?} */\n            var shouldRunGuardsAndResolvers = this.shouldRunGuardsAndResolvers(curr, future, /** @type {?} */ ((future.routeConfig)).runGuardsAndResolvers);\n            if (shouldRunGuardsAndResolvers) {\n                this.canActivateChecks.push(new CanActivate(futurePath));\n            }\n            else {\n                // we need to set the data\n                future.data = curr.data;\n                future._resolvedData = curr._resolvedData;\n            }\n            // If we have a component, we need to go through an outlet.\n            if (future.component) {\n                this.setupChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath);\n                // if we have a componentless route, we recurse but keep the same outlet map.\n            }\n            else {\n                this.setupChildRouteGuards(futureNode, currNode, parentContexts, futurePath);\n            }\n            if (shouldRunGuardsAndResolvers) {\n                /** @type {?} */\n                var outlet = /** @type {?} */ ((/** @type {?} */ ((context)).outlet));\n                this.canDeactivateChecks.push(new CanDeactivate(outlet.component, curr));\n            }\n        }\n        else {\n            if (curr) {\n                this.deactivateRouteAndItsChildren(currNode, context);\n            }\n            this.canActivateChecks.push(new CanActivate(futurePath));\n            // If we have a component, we need to go through an outlet.\n            if (future.component) {\n                this.setupChildRouteGuards(futureNode, null, context ? context.children : null, futurePath);\n                // if we have a componentless route, we recurse but keep the same outlet map.\n            }\n            else {\n                this.setupChildRouteGuards(futureNode, null, parentContexts, futurePath);\n            }\n        }\n    };\n    /**\n     * @param {?} curr\n     * @param {?} future\n     * @param {?} mode\n     * @return {?}\n     */\n    PreActivation.prototype.shouldRunGuardsAndResolvers = /**\n     * @param {?} curr\n     * @param {?} future\n     * @param {?} mode\n     * @return {?}\n     */\n    function (curr, future, mode) {\n        switch (mode) {\n            case 'always':\n                return true;\n            case 'paramsOrQueryParamsChange':\n                return !equalParamsAndUrlSegments(curr, future) ||\n                    !shallowEqual(curr.queryParams, future.queryParams);\n            case 'paramsChange':\n            default:\n                return !equalParamsAndUrlSegments(curr, future);\n        }\n    };\n    /**\n     * @param {?} route\n     * @param {?} context\n     * @return {?}\n     */\n    PreActivation.prototype.deactivateRouteAndItsChildren = /**\n     * @param {?} route\n     * @param {?} context\n     * @return {?}\n     */\n    function (route, context) {\n        var _this = this;\n        /** @type {?} */\n        var children = nodeChildrenAsMap(route);\n        /** @type {?} */\n        var r = route.value;\n        forEach(children, function (node, childName) {\n            if (!r.component) {\n                _this.deactivateRouteAndItsChildren(node, context);\n            }\n            else if (context) {\n                _this.deactivateRouteAndItsChildren(node, context.children.getContext(childName));\n            }\n            else {\n                _this.deactivateRouteAndItsChildren(node, null);\n            }\n        });\n        if (!r.component) {\n            this.canDeactivateChecks.push(new CanDeactivate(null, r));\n        }\n        else if (context && context.outlet && context.outlet.isActivated) {\n            this.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n        }\n        else {\n            this.canDeactivateChecks.push(new CanDeactivate(null, r));\n        }\n    };\n    /**\n     * @return {?}\n     */\n    PreActivation.prototype.runCanDeactivateChecks = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        return from(this.canDeactivateChecks)\n            .pipe(mergeMap(function (check) { return _this.runCanDeactivate(check.component, check.route); }), every(function (result) { return result === true; }));\n    };\n    /**\n     * @return {?}\n     */\n    PreActivation.prototype.runCanActivateChecks = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        return from(this.canActivateChecks)\n            .pipe(concatMap(function (check) { return andObservables(from([\n            _this.fireChildActivationStart(check.route.parent),\n            _this.fireActivationStart(check.route), _this.runCanActivateChild(check.path),\n            _this.runCanActivate(check.route)\n        ])); }), every(function (result) { return result === true; }));\n        // this.fireChildActivationStart(check.path),\n    };\n    /**\n     * This should fire off `ActivationStart` events for each route being activated at this\n     * level.\n     * In other words, if you're activating `a` and `b` below, `path` will contain the\n     * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n     * return\n     * `true` so checks continue to run.\n     * @param {?} snapshot\n     * @return {?}\n     */\n    PreActivation.prototype.fireActivationStart = /**\n     * This should fire off `ActivationStart` events for each route being activated at this\n     * level.\n     * In other words, if you're activating `a` and `b` below, `path` will contain the\n     * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n     * return\n     * `true` so checks continue to run.\n     * @param {?} snapshot\n     * @return {?}\n     */\n    function (snapshot) {\n        if (snapshot !== null && this.forwardEvent) {\n            this.forwardEvent(new ActivationStart(snapshot));\n        }\n        return of(true);\n    };\n    /**\n     * This should fire off `ChildActivationStart` events for each route being activated at this\n     * level.\n     * In other words, if you're activating `a` and `b` below, `path` will contain the\n     * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n     * return\n     * `true` so checks continue to run.\n     * @param {?} snapshot\n     * @return {?}\n     */\n    PreActivation.prototype.fireChildActivationStart = /**\n     * This should fire off `ChildActivationStart` events for each route being activated at this\n     * level.\n     * In other words, if you're activating `a` and `b` below, `path` will contain the\n     * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n     * return\n     * `true` so checks continue to run.\n     * @param {?} snapshot\n     * @return {?}\n     */\n    function (snapshot) {\n        if (snapshot !== null && this.forwardEvent) {\n            this.forwardEvent(new ChildActivationStart(snapshot));\n        }\n        return of(true);\n    };\n    /**\n     * @param {?} future\n     * @return {?}\n     */\n    PreActivation.prototype.runCanActivate = /**\n     * @param {?} future\n     * @return {?}\n     */\n    function (future) {\n        var _this = this;\n        /** @type {?} */\n        var canActivate = future.routeConfig ? future.routeConfig.canActivate : null;\n        if (!canActivate || canActivate.length === 0)\n            return of(true);\n        /** @type {?} */\n        var obs = from(canActivate).pipe(map(function (c) {\n            /** @type {?} */\n            var guard = _this.getToken(c, future);\n            /** @type {?} */\n            var observable;\n            if (guard.canActivate) {\n                observable = wrapIntoObservable(guard.canActivate(future, _this.future));\n            }\n            else {\n                observable = wrapIntoObservable(guard(future, _this.future));\n            }\n            return observable.pipe(first());\n        }));\n        return andObservables(obs);\n    };\n    /**\n     * @param {?} path\n     * @return {?}\n     */\n    PreActivation.prototype.runCanActivateChild = /**\n     * @param {?} path\n     * @return {?}\n     */\n    function (path) {\n        var _this = this;\n        /** @type {?} */\n        var future = path[path.length - 1];\n        /** @type {?} */\n        var canActivateChildGuards = path.slice(0, path.length - 1)\n            .reverse()\n            .map(function (p) { return _this.extractCanActivateChild(p); })\n            .filter(function (_) { return _ !== null; });\n        return andObservables(from(canActivateChildGuards).pipe(map(function (d) {\n            /** @type {?} */\n            var obs = from(d.guards).pipe(map(function (c) {\n                /** @type {?} */\n                var guard = _this.getToken(c, d.node);\n                /** @type {?} */\n                var observable;\n                if (guard.canActivateChild) {\n                    observable = wrapIntoObservable(guard.canActivateChild(future, _this.future));\n                }\n                else {\n                    observable = wrapIntoObservable(guard(future, _this.future));\n                }\n                return observable.pipe(first());\n            }));\n            return andObservables(obs);\n        })));\n    };\n    /**\n     * @param {?} p\n     * @return {?}\n     */\n    PreActivation.prototype.extractCanActivateChild = /**\n     * @param {?} p\n     * @return {?}\n     */\n    function (p) {\n        /** @type {?} */\n        var canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n        if (!canActivateChild || canActivateChild.length === 0)\n            return null;\n        return { node: p, guards: canActivateChild };\n    };\n    /**\n     * @param {?} component\n     * @param {?} curr\n     * @return {?}\n     */\n    PreActivation.prototype.runCanDeactivate = /**\n     * @param {?} component\n     * @param {?} curr\n     * @return {?}\n     */\n    function (component, curr) {\n        var _this = this;\n        /** @type {?} */\n        var canDeactivate = curr && curr.routeConfig ? curr.routeConfig.canDeactivate : null;\n        if (!canDeactivate || canDeactivate.length === 0)\n            return of(true);\n        /** @type {?} */\n        var canDeactivate$ = from(canDeactivate).pipe(mergeMap(function (c) {\n            /** @type {?} */\n            var guard = _this.getToken(c, curr);\n            /** @type {?} */\n            var observable;\n            if (guard.canDeactivate) {\n                observable =\n                    wrapIntoObservable(guard.canDeactivate(component, curr, _this.curr, _this.future));\n            }\n            else {\n                observable = wrapIntoObservable(guard(component, curr, _this.curr, _this.future));\n            }\n            return observable.pipe(first());\n        }));\n        return canDeactivate$.pipe(every(function (result) { return result === true; }));\n    };\n    /**\n     * @param {?} future\n     * @param {?} paramsInheritanceStrategy\n     * @return {?}\n     */\n    PreActivation.prototype.runResolve = /**\n     * @param {?} future\n     * @param {?} paramsInheritanceStrategy\n     * @return {?}\n     */\n    function (future, paramsInheritanceStrategy) {\n        /** @type {?} */\n        var resolve = future._resolve;\n        return this.resolveNode(resolve, future).pipe(map(function (resolvedData) {\n            future._resolvedData = resolvedData;\n            future.data = tslib_1.__assign({}, future.data, inheritedParamsDataResolve(future, paramsInheritanceStrategy).resolve);\n            return null;\n        }));\n    };\n    /**\n     * @param {?} resolve\n     * @param {?} future\n     * @return {?}\n     */\n    PreActivation.prototype.resolveNode = /**\n     * @param {?} resolve\n     * @param {?} future\n     * @return {?}\n     */\n    function (resolve, future) {\n        var _this = this;\n        /** @type {?} */\n        var keys = Object.keys(resolve);\n        if (keys.length === 0) {\n            return of({});\n        }\n        if (keys.length === 1) {\n            /** @type {?} */\n            var key_1 = keys[0];\n            return this.getResolver(resolve[key_1], future).pipe(map(function (value) {\n                var _a;\n                return _a = {}, _a[key_1] = value, _a;\n            }));\n        }\n        /** @type {?} */\n        var data = {};\n        /** @type {?} */\n        var runningResolvers$ = from(keys).pipe(mergeMap(function (key) {\n            return _this.getResolver(resolve[key], future).pipe(map(function (value) {\n                data[key] = value;\n                return value;\n            }));\n        }));\n        return runningResolvers$.pipe(last(), map(function () { return data; }));\n    };\n    /**\n     * @param {?} injectionToken\n     * @param {?} future\n     * @return {?}\n     */\n    PreActivation.prototype.getResolver = /**\n     * @param {?} injectionToken\n     * @param {?} future\n     * @return {?}\n     */\n    function (injectionToken, future) {\n        /** @type {?} */\n        var resolver = this.getToken(injectionToken, future);\n        return resolver.resolve ? wrapIntoObservable(resolver.resolve(future, this.future)) :\n            wrapIntoObservable(resolver(future, this.future));\n    };\n    /**\n     * @param {?} token\n     * @param {?} snapshot\n     * @return {?}\n     */\n    PreActivation.prototype.getToken = /**\n     * @param {?} token\n     * @param {?} snapshot\n     * @return {?}\n     */\n    function (token, snapshot) {\n        /** @type {?} */\n        var config = closestLoadedConfig(snapshot);\n        /** @type {?} */\n        var injector = config ? config.module.injector : this.moduleInjector;\n        return injector.get(token);\n    };\n    return PreActivation;\n}());\n/**\n * This class bundles the actions involved in preactivation of a route.\n */\nexport { PreActivation };\nif (false) {\n    /** @type {?} */\n    PreActivation.prototype.canActivateChecks;\n    /** @type {?} */\n    PreActivation.prototype.canDeactivateChecks;\n    /** @type {?} */\n    PreActivation.prototype.future;\n    /** @type {?} */\n    PreActivation.prototype.curr;\n    /** @type {?} */\n    PreActivation.prototype.moduleInjector;\n    /** @type {?} */\n    PreActivation.prototype.forwardEvent;\n}\n/**\n * @param {?} snapshot\n * @return {?}\n */\nfunction closestLoadedConfig(snapshot) {\n    if (!snapshot)\n        return null;\n    for (var s = snapshot.parent; s; s = s.parent) {\n        /** @type {?} */\n        var route = s.routeConfig;\n        if (route && route._loadedConfig)\n            return route._loadedConfig;\n    }\n    return null;\n}\n//# sourceMappingURL=pre_activation.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as tslib_1 from \"tslib\";\nimport { Observable, of } from 'rxjs';\nimport { ActivatedRouteSnapshot, RouterStateSnapshot, inheritedParamsDataResolve } from './router_state';\nimport { PRIMARY_OUTLET, defaultUrlMatcher } from './shared';\nimport { UrlSegmentGroup, mapChildrenIntoArray } from './url_tree';\nimport { forEach, last } from './utils/collection';\nimport { TreeNode } from './utils/tree';\nvar NoMatch = /** @class */ (function () {\n    function NoMatch() {\n    }\n    return NoMatch;\n}());\n/**\n * @param {?} rootComponentType\n * @param {?} config\n * @param {?} urlTree\n * @param {?} url\n * @param {?=} paramsInheritanceStrategy\n * @param {?=} relativeLinkResolution\n * @return {?}\n */\nexport function recognize(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution) {\n    if (paramsInheritanceStrategy === void 0) { paramsInheritanceStrategy = 'emptyOnly'; }\n    if (relativeLinkResolution === void 0) { relativeLinkResolution = 'legacy'; }\n    return new Recognizer(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution)\n        .recognize();\n}\nvar Recognizer = /** @class */ (function () {\n    function Recognizer(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution) {\n        this.rootComponentType = rootComponentType;\n        this.config = config;\n        this.urlTree = urlTree;\n        this.url = url;\n        this.paramsInheritanceStrategy = paramsInheritanceStrategy;\n        this.relativeLinkResolution = relativeLinkResolution;\n    }\n    /**\n     * @return {?}\n     */\n    Recognizer.prototype.recognize = /**\n     * @return {?}\n     */\n    function () {\n        try {\n            /** @type {?} */\n            var rootSegmentGroup = split(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup;\n            /** @type {?} */\n            var children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);\n            /** @type {?} */\n            var root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(tslib_1.__assign({}, this.urlTree.queryParams)), /** @type {?} */ ((this.urlTree.fragment)), {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});\n            /** @type {?} */\n            var rootNode = new TreeNode(root, children);\n            /** @type {?} */\n            var routeState = new RouterStateSnapshot(this.url, rootNode);\n            this.inheritParamsAndData(routeState._root);\n            return of(routeState);\n        }\n        catch (e) {\n            return new Observable(function (obs) { return obs.error(e); });\n        }\n    };\n    /**\n     * @param {?} routeNode\n     * @return {?}\n     */\n    Recognizer.prototype.inheritParamsAndData = /**\n     * @param {?} routeNode\n     * @return {?}\n     */\n    function (routeNode) {\n        var _this = this;\n        /** @type {?} */\n        var route = routeNode.value;\n        /** @type {?} */\n        var i = inheritedParamsDataResolve(route, this.paramsInheritanceStrategy);\n        route.params = Object.freeze(i.params);\n        route.data = Object.freeze(i.data);\n        routeNode.children.forEach(function (n) { return _this.inheritParamsAndData(n); });\n    };\n    /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @param {?} outlet\n     * @return {?}\n     */\n    Recognizer.prototype.processSegmentGroup = /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (config, segmentGroup, outlet) {\n        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n            return this.processChildren(config, segmentGroup);\n        }\n        return this.processSegment(config, segmentGroup, segmentGroup.segments, outlet);\n    };\n    /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @return {?}\n     */\n    Recognizer.prototype.processChildren = /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @return {?}\n     */\n    function (config, segmentGroup) {\n        var _this = this;\n        /** @type {?} */\n        var children = mapChildrenIntoArray(segmentGroup, function (child, childOutlet) { return _this.processSegmentGroup(config, child, childOutlet); });\n        checkOutletNameUniqueness(children);\n        sortActivatedRouteSnapshots(children);\n        return children;\n    };\n    /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    Recognizer.prototype.processSegment = /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (config, segmentGroup, segments, outlet) {\n        for (var _i = 0, config_1 = config; _i < config_1.length; _i++) {\n            var r = config_1[_i];\n            try {\n                return this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);\n            }\n            catch (e) {\n                if (!(e instanceof NoMatch))\n                    throw e;\n            }\n        }\n        if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n            return [];\n        }\n        throw new NoMatch();\n    };\n    /**\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    Recognizer.prototype.noLeftoversInUrl = /**\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (segmentGroup, segments, outlet) {\n        return segments.length === 0 && !segmentGroup.children[outlet];\n    };\n    /**\n     * @param {?} route\n     * @param {?} rawSegment\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    Recognizer.prototype.processSegmentAgainstRoute = /**\n     * @param {?} route\n     * @param {?} rawSegment\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (route, rawSegment, segments, outlet) {\n        if (route.redirectTo)\n            throw new NoMatch();\n        if ((route.outlet || PRIMARY_OUTLET) !== outlet)\n            throw new NoMatch();\n        /** @type {?} */\n        var snapshot;\n        /** @type {?} */\n        var consumedSegments = [];\n        /** @type {?} */\n        var rawSlicedSegments = [];\n        if (route.path === '**') {\n            /** @type {?} */\n            var params = segments.length > 0 ? /** @type {?} */ ((last(segments))).parameters : {};\n            snapshot = new ActivatedRouteSnapshot(segments, params, Object.freeze(tslib_1.__assign({}, this.urlTree.queryParams)), /** @type {?} */ ((this.urlTree.fragment)), getData(route), outlet, /** @type {?} */ ((route.component)), route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));\n        }\n        else {\n            /** @type {?} */\n            var result = match(rawSegment, route, segments);\n            consumedSegments = result.consumedSegments;\n            rawSlicedSegments = segments.slice(result.lastChild);\n            snapshot = new ActivatedRouteSnapshot(consumedSegments, result.parameters, Object.freeze(tslib_1.__assign({}, this.urlTree.queryParams)), /** @type {?} */ ((this.urlTree.fragment)), getData(route), outlet, /** @type {?} */ ((route.component)), route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));\n        }\n        /** @type {?} */\n        var childConfig = getChildConfig(route);\n        var _a = split(rawSegment, consumedSegments, rawSlicedSegments, childConfig, this.relativeLinkResolution), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;\n        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n            /** @type {?} */\n            var children_1 = this.processChildren(childConfig, segmentGroup);\n            return [new TreeNode(snapshot, children_1)];\n        }\n        if (childConfig.length === 0 && slicedSegments.length === 0) {\n            return [new TreeNode(snapshot, [])];\n        }\n        /** @type {?} */\n        var children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);\n        return [new TreeNode(snapshot, children)];\n    };\n    return Recognizer;\n}());\nif (false) {\n    /** @type {?} */\n    Recognizer.prototype.rootComponentType;\n    /** @type {?} */\n    Recognizer.prototype.config;\n    /** @type {?} */\n    Recognizer.prototype.urlTree;\n    /** @type {?} */\n    Recognizer.prototype.url;\n    /** @type {?} */\n    Recognizer.prototype.paramsInheritanceStrategy;\n    /** @type {?} */\n    Recognizer.prototype.relativeLinkResolution;\n}\n/**\n * @param {?} nodes\n * @return {?}\n */\nfunction sortActivatedRouteSnapshots(nodes) {\n    nodes.sort(function (a, b) {\n        if (a.value.outlet === PRIMARY_OUTLET)\n            return -1;\n        if (b.value.outlet === PRIMARY_OUTLET)\n            return 1;\n        return a.value.outlet.localeCompare(b.value.outlet);\n    });\n}\n/**\n * @param {?} route\n * @return {?}\n */\nfunction getChildConfig(route) {\n    if (route.children) {\n        return route.children;\n    }\n    if (route.loadChildren) {\n        return /** @type {?} */ ((route._loadedConfig)).routes;\n    }\n    return [];\n}\n/**\n * @record\n */\nfunction MatchResult() { }\n/** @type {?} */\nMatchResult.prototype.consumedSegments;\n/** @type {?} */\nMatchResult.prototype.lastChild;\n/** @type {?} */\nMatchResult.prototype.parameters;\n/**\n * @param {?} segmentGroup\n * @param {?} route\n * @param {?} segments\n * @return {?}\n */\nfunction match(segmentGroup, route, segments) {\n    if (route.path === '') {\n        if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n            throw new NoMatch();\n        }\n        return { consumedSegments: [], lastChild: 0, parameters: {} };\n    }\n    /** @type {?} */\n    var matcher = route.matcher || defaultUrlMatcher;\n    /** @type {?} */\n    var res = matcher(segments, segmentGroup, route);\n    if (!res)\n        throw new NoMatch();\n    /** @type {?} */\n    var posParams = {};\n    forEach(/** @type {?} */ ((res.posParams)), function (v, k) { posParams[k] = v.path; });\n    /** @type {?} */\n    var parameters = res.consumed.length > 0 ? tslib_1.__assign({}, posParams, res.consumed[res.consumed.length - 1].parameters) :\n        posParams;\n    return { consumedSegments: res.consumed, lastChild: res.consumed.length, parameters: parameters };\n}\n/**\n * @param {?} nodes\n * @return {?}\n */\nfunction checkOutletNameUniqueness(nodes) {\n    /** @type {?} */\n    var names = {};\n    nodes.forEach(function (n) {\n        /** @type {?} */\n        var routeWithSameOutletName = names[n.value.outlet];\n        if (routeWithSameOutletName) {\n            /** @type {?} */\n            var p = routeWithSameOutletName.url.map(function (s) { return s.toString(); }).join('/');\n            /** @type {?} */\n            var c = n.value.url.map(function (s) { return s.toString(); }).join('/');\n            throw new Error(\"Two segments cannot have the same outlet name: '\" + p + \"' and '\" + c + \"'.\");\n        }\n        names[n.value.outlet] = n.value;\n    });\n}\n/**\n * @param {?} segmentGroup\n * @return {?}\n */\nfunction getSourceSegmentGroup(segmentGroup) {\n    /** @type {?} */\n    var s = segmentGroup;\n    while (s._sourceSegment) {\n        s = s._sourceSegment;\n    }\n    return s;\n}\n/**\n * @param {?} segmentGroup\n * @return {?}\n */\nfunction getPathIndexShift(segmentGroup) {\n    /** @type {?} */\n    var s = segmentGroup;\n    /** @type {?} */\n    var res = (s._segmentIndexShift ? s._segmentIndexShift : 0);\n    while (s._sourceSegment) {\n        s = s._sourceSegment;\n        res += (s._segmentIndexShift ? s._segmentIndexShift : 0);\n    }\n    return res - 1;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} slicedSegments\n * @param {?} config\n * @param {?} relativeLinkResolution\n * @return {?}\n */\nfunction split(segmentGroup, consumedSegments, slicedSegments, config, relativeLinkResolution) {\n    if (slicedSegments.length > 0 &&\n        containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n        /** @type {?} */\n        var s_1 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n        s_1._sourceSegment = segmentGroup;\n        s_1._segmentIndexShift = consumedSegments.length;\n        return { segmentGroup: s_1, slicedSegments: [] };\n    }\n    if (slicedSegments.length === 0 &&\n        containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n        /** @type {?} */\n        var s_2 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, config, segmentGroup.children, relativeLinkResolution));\n        s_2._sourceSegment = segmentGroup;\n        s_2._segmentIndexShift = consumedSegments.length;\n        return { segmentGroup: s_2, slicedSegments: slicedSegments };\n    }\n    /** @type {?} */\n    var s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n    s._sourceSegment = segmentGroup;\n    s._segmentIndexShift = consumedSegments.length;\n    return { segmentGroup: s, slicedSegments: slicedSegments };\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} slicedSegments\n * @param {?} routes\n * @param {?} children\n * @param {?} relativeLinkResolution\n * @return {?}\n */\nfunction addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, routes, children, relativeLinkResolution) {\n    /** @type {?} */\n    var res = {};\n    for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n        var r = routes_1[_i];\n        if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n            /** @type {?} */\n            var s = new UrlSegmentGroup([], {});\n            s._sourceSegment = segmentGroup;\n            if (relativeLinkResolution === 'legacy') {\n                s._segmentIndexShift = segmentGroup.segments.length;\n            }\n            else {\n                s._segmentIndexShift = consumedSegments.length;\n            }\n            res[getOutlet(r)] = s;\n        }\n    }\n    return tslib_1.__assign({}, children, res);\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} routes\n * @param {?} primarySegment\n * @return {?}\n */\nfunction createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {\n    /** @type {?} */\n    var res = {};\n    res[PRIMARY_OUTLET] = primarySegment;\n    primarySegment._sourceSegment = segmentGroup;\n    primarySegment._segmentIndexShift = consumedSegments.length;\n    for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {\n        var r = routes_2[_i];\n        if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n            /** @type {?} */\n            var s = new UrlSegmentGroup([], {});\n            s._sourceSegment = segmentGroup;\n            s._segmentIndexShift = consumedSegments.length;\n            res[getOutlet(r)] = s;\n        }\n    }\n    return res;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @return {?}\n */\nfunction containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n    return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET; });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @return {?}\n */\nfunction containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\n    return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r); });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} r\n * @return {?}\n */\nfunction emptyPathMatch(segmentGroup, slicedSegments, r) {\n    if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n        return false;\n    }\n    return r.path === '' && r.redirectTo === undefined;\n}\n/**\n * @param {?} route\n * @return {?}\n */\nfunction getOutlet(route) {\n    return route.outlet || PRIMARY_OUTLET;\n}\n/**\n * @param {?} route\n * @return {?}\n */\nfunction getData(route) {\n    return route.data || {};\n}\n/**\n * @param {?} route\n * @return {?}\n */\nfunction getResolve(route) {\n    return route.resolve || {};\n}\n//# sourceMappingURL=recognize.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** @typedef {?} */\nvar DetachedRouteHandle;\nexport { DetachedRouteHandle };\n/** @typedef {?} */\nvar DetachedRouteHandleInternal;\nexport { DetachedRouteHandleInternal };\n/**\n * \\@description\n *\n * Provides a way to customize when activated routes get reused.\n *\n * \\@experimental\n * @abstract\n */\nvar /**\n * \\@description\n *\n * Provides a way to customize when activated routes get reused.\n *\n * \\@experimental\n * @abstract\n */\nRouteReuseStrategy = /** @class */ (function () {\n    function RouteReuseStrategy() {\n    }\n    return RouteReuseStrategy;\n}());\n/**\n * \\@description\n *\n * Provides a way to customize when activated routes get reused.\n *\n * \\@experimental\n * @abstract\n */\nexport { RouteReuseStrategy };\nif (false) {\n    /**\n     * Determines if this route (and its subtree) should be detached to be reused later\n     * @abstract\n     * @param {?} route\n     * @return {?}\n     */\n    RouteReuseStrategy.prototype.shouldDetach = function (route) { };\n    /**\n     * Stores the detached route.\n     *\n     * Storing a `null` value should erase the previously stored value.\n     * @abstract\n     * @param {?} route\n     * @param {?} handle\n     * @return {?}\n     */\n    RouteReuseStrategy.prototype.store = function (route, handle) { };\n    /**\n     * Determines if this route (and its subtree) should be reattached\n     * @abstract\n     * @param {?} route\n     * @return {?}\n     */\n    RouteReuseStrategy.prototype.shouldAttach = function (route) { };\n    /**\n     * Retrieves the previously stored route\n     * @abstract\n     * @param {?} route\n     * @return {?}\n     */\n    RouteReuseStrategy.prototype.retrieve = function (route) { };\n    /**\n     * Determines if a route should be reused\n     * @abstract\n     * @param {?} future\n     * @param {?} curr\n     * @return {?}\n     */\n    RouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) { };\n}\n/**\n * Does not detach any subtrees. Reuses routes as long as their route config is the same.\n */\nvar /**\n * Does not detach any subtrees. Reuses routes as long as their route config is the same.\n */\nDefaultRouteReuseStrategy = /** @class */ (function () {\n    function DefaultRouteReuseStrategy() {\n    }\n    /**\n     * @param {?} route\n     * @return {?}\n     */\n    DefaultRouteReuseStrategy.prototype.shouldDetach = /**\n     * @param {?} route\n     * @return {?}\n     */\n    function (route) { return false; };\n    /**\n     * @param {?} route\n     * @param {?} detachedTree\n     * @return {?}\n     */\n    DefaultRouteReuseStrategy.prototype.store = /**\n     * @param {?} route\n     * @param {?} detachedTree\n     * @return {?}\n     */\n    function (route, detachedTree) { };\n    /**\n     * @param {?} route\n     * @return {?}\n     */\n    DefaultRouteReuseStrategy.prototype.shouldAttach = /**\n     * @param {?} route\n     * @return {?}\n     */\n    function (route) { return false; };\n    /**\n     * @param {?} route\n     * @return {?}\n     */\n    DefaultRouteReuseStrategy.prototype.retrieve = /**\n     * @param {?} route\n     * @return {?}\n     */\n    function (route) { return null; };\n    /**\n     * @param {?} future\n     * @param {?} curr\n     * @return {?}\n     */\n    DefaultRouteReuseStrategy.prototype.shouldReuseRoute = /**\n     * @param {?} future\n     * @param {?} curr\n     * @return {?}\n     */\n    function (future, curr) {\n        return future.routeConfig === curr.routeConfig;\n    };\n    return DefaultRouteReuseStrategy;\n}());\n/**\n * Does not detach any subtrees. Reuses routes as long as their route config is the same.\n */\nexport { DefaultRouteReuseStrategy };\n//# sourceMappingURL=route_reuse_strategy.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InjectionToken, NgModuleFactory } from '@angular/core';\nimport { from, of } from 'rxjs';\nimport { map, mergeMap } from 'rxjs/operators';\nimport { LoadedRouterConfig, standardizeConfig } from './config';\nimport { flatten, wrapIntoObservable } from './utils/collection';\n/** *\n * \\@docsNotRequired\n * \\@experimental\n  @type {?} */\nexport var ROUTES = new InjectionToken('ROUTES');\nvar RouterConfigLoader = /** @class */ (function () {\n    function RouterConfigLoader(loader, compiler, onLoadStartListener, onLoadEndListener) {\n        this.loader = loader;\n        this.compiler = compiler;\n        this.onLoadStartListener = onLoadStartListener;\n        this.onLoadEndListener = onLoadEndListener;\n    }\n    /**\n     * @param {?} parentInjector\n     * @param {?} route\n     * @return {?}\n     */\n    RouterConfigLoader.prototype.load = /**\n     * @param {?} parentInjector\n     * @param {?} route\n     * @return {?}\n     */\n    function (parentInjector, route) {\n        var _this = this;\n        if (this.onLoadStartListener) {\n            this.onLoadStartListener(route);\n        }\n        /** @type {?} */\n        var moduleFactory$ = this.loadModuleFactory(/** @type {?} */ ((route.loadChildren)));\n        return moduleFactory$.pipe(map(function (factory) {\n            if (_this.onLoadEndListener) {\n                _this.onLoadEndListener(route);\n            }\n            /** @type {?} */\n            var module = factory.create(parentInjector);\n            return new LoadedRouterConfig(flatten(module.injector.get(ROUTES)).map(standardizeConfig), module);\n        }));\n    };\n    /**\n     * @param {?} loadChildren\n     * @return {?}\n     */\n    RouterConfigLoader.prototype.loadModuleFactory = /**\n     * @param {?} loadChildren\n     * @return {?}\n     */\n    function (loadChildren) {\n        var _this = this;\n        if (typeof loadChildren === 'string') {\n            return from(this.loader.load(loadChildren));\n        }\n        else {\n            return wrapIntoObservable(loadChildren()).pipe(mergeMap(function (t) {\n                if (t instanceof NgModuleFactory) {\n                    return of(t);\n                }\n                else {\n                    return from(_this.compiler.compileModuleAsync(t));\n                }\n            }));\n        }\n    };\n    return RouterConfigLoader;\n}());\nexport { RouterConfigLoader };\nif (false) {\n    /** @type {?} */\n    RouterConfigLoader.prototype.loader;\n    /** @type {?} */\n    RouterConfigLoader.prototype.compiler;\n    /** @type {?} */\n    RouterConfigLoader.prototype.onLoadStartListener;\n    /** @type {?} */\n    RouterConfigLoader.prototype.onLoadEndListener;\n}\n//# sourceMappingURL=router_config_loader.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * \\@description\n *\n * Provides a way to migrate AngularJS applications to Angular.\n *\n * \\@experimental\n * @abstract\n */\nvar /**\n * \\@description\n *\n * Provides a way to migrate AngularJS applications to Angular.\n *\n * \\@experimental\n * @abstract\n */\nUrlHandlingStrategy = /** @class */ (function () {\n    function UrlHandlingStrategy() {\n    }\n    return UrlHandlingStrategy;\n}());\n/**\n * \\@description\n *\n * Provides a way to migrate AngularJS applications to Angular.\n *\n * \\@experimental\n * @abstract\n */\nexport { UrlHandlingStrategy };\nif (false) {\n    /**\n     * Tells the router if this URL should be processed.\n     *\n     * When it returns true, the router will execute the regular navigation.\n     * When it returns false, the router will set the router state to an empty state.\n     * As a result, all the active components will be destroyed.\n     *\n     * @abstract\n     * @param {?} url\n     * @return {?}\n     */\n    UrlHandlingStrategy.prototype.shouldProcessUrl = function (url) { };\n    /**\n     * Extracts the part of the URL that should be handled by the router.\n     * The rest of the URL will remain untouched.\n     * @abstract\n     * @param {?} url\n     * @return {?}\n     */\n    UrlHandlingStrategy.prototype.extract = function (url) { };\n    /**\n     * Merges the URL fragment with the rest of the URL.\n     * @abstract\n     * @param {?} newUrlPart\n     * @param {?} rawUrl\n     * @return {?}\n     */\n    UrlHandlingStrategy.prototype.merge = function (newUrlPart, rawUrl) { };\n}\n/**\n * \\@experimental\n */\nvar /**\n * \\@experimental\n */\nDefaultUrlHandlingStrategy = /** @class */ (function () {\n    function DefaultUrlHandlingStrategy() {\n    }\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    DefaultUrlHandlingStrategy.prototype.shouldProcessUrl = /**\n     * @param {?} url\n     * @return {?}\n     */\n    function (url) { return true; };\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    DefaultUrlHandlingStrategy.prototype.extract = /**\n     * @param {?} url\n     * @return {?}\n     */\n    function (url) { return url; };\n    /**\n     * @param {?} newUrlPart\n     * @param {?} wholeUrl\n     * @return {?}\n     */\n    DefaultUrlHandlingStrategy.prototype.merge = /**\n     * @param {?} newUrlPart\n     * @param {?} wholeUrl\n     * @return {?}\n     */\n    function (newUrlPart, wholeUrl) { return newUrlPart; };\n    return DefaultUrlHandlingStrategy;\n}());\n/**\n * \\@experimental\n */\nexport { DefaultUrlHandlingStrategy };\n//# sourceMappingURL=url_handling_strategy.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as tslib_1 from \"tslib\";\nimport { NgModuleRef, isDevMode } from '@angular/core';\nimport { BehaviorSubject, Subject, of } from 'rxjs';\nimport { concatMap, map, mergeMap } from 'rxjs/operators';\nimport { applyRedirects } from './apply_redirects';\nimport { standardizeConfig, validateConfig } from './config';\nimport { createRouterState } from './create_router_state';\nimport { createUrlTree } from './create_url_tree';\nimport { ActivationEnd, ChildActivationEnd, GuardsCheckEnd, GuardsCheckStart, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RoutesRecognized } from './events';\nimport { PreActivation } from './pre_activation';\nimport { recognize } from './recognize';\nimport { DefaultRouteReuseStrategy } from './route_reuse_strategy';\nimport { RouterConfigLoader } from './router_config_loader';\nimport { advanceActivatedRoute, createEmptyState } from './router_state';\nimport { isNavigationCancelingError } from './shared';\nimport { DefaultUrlHandlingStrategy } from './url_handling_strategy';\nimport { UrlTree, containsTree, createEmptyUrlTree } from './url_tree';\nimport { forEach } from './utils/collection';\nimport { nodeChildrenAsMap } from './utils/tree';\n/**\n * \\@description\n *\n * Represents the extra options used during navigation.\n *\n *\n * @record\n */\nexport function NavigationExtras() { }\n/**\n * Enables relative navigation from the current ActivatedRoute.\n *\n * Configuration:\n *\n * ```\n * [{\n *   path: 'parent',\n *   component: ParentComponent,\n *   children: [{\n *     path: 'list',\n *     component: ListComponent\n *   },{\n *     path: 'child',\n *     component: ChildComponent\n *   }]\n * }]\n * ```\n *\n * Navigate to list route from child route:\n *\n * ```\n * \\@Component({...})\n *  class ChildComponent {\n *    constructor(private router: Router, private route: ActivatedRoute) {}\n *\n *    go() {\n *      this.router.navigate(['../list'], { relativeTo: this.route });\n *    }\n *  }\n * ```\n * @type {?|undefined}\n */\nNavigationExtras.prototype.relativeTo;\n/**\n * Sets query parameters to the URL.\n *\n * ```\n * // Navigate to /results?page=1\n * this.router.navigate(['/results'], { queryParams: { page: 1 } });\n * ```\n * @type {?|undefined}\n */\nNavigationExtras.prototype.queryParams;\n/**\n * Sets the hash fragment for the URL.\n *\n * ```\n * // Navigate to /results#top\n * this.router.navigate(['/results'], { fragment: 'top' });\n * ```\n * @type {?|undefined}\n */\nNavigationExtras.prototype.fragment;\n/**\n * Preserves the query parameters for the next navigation.\n *\n * deprecated, use `queryParamsHandling` instead\n *\n * ```\n * // Preserve query params from /results?page=1 to /view?page=1\n * this.router.navigate(['/view'], { preserveQueryParams: true });\n * ```\n *\n * @deprecated since v4\n * @type {?|undefined}\n */\nNavigationExtras.prototype.preserveQueryParams;\n/**\n *  config strategy to handle the query parameters for the next navigation.\n *\n * ```\n * // from /results?page=1 to /view?page=1&page=2\n * this.router.navigate(['/view'], { queryParams: { page: 2 },  queryParamsHandling: \"merge\" });\n * ```\n * @type {?|undefined}\n */\nNavigationExtras.prototype.queryParamsHandling;\n/**\n * Preserves the fragment for the next navigation\n *\n * ```\n * // Preserve fragment from /results#top to /view#top\n * this.router.navigate(['/view'], { preserveFragment: true });\n * ```\n * @type {?|undefined}\n */\nNavigationExtras.prototype.preserveFragment;\n/**\n * Navigates without pushing a new state into history.\n *\n * ```\n * // Navigate silently to /view\n * this.router.navigate(['/view'], { skipLocationChange: true });\n * ```\n * @type {?|undefined}\n */\nNavigationExtras.prototype.skipLocationChange;\n/**\n * Navigates while replacing the current state in history.\n *\n * ```\n * // Navigate to /view\n * this.router.navigate(['/view'], { replaceUrl: true });\n * ```\n * @type {?|undefined}\n */\nNavigationExtras.prototype.replaceUrl;\n/** @typedef {?} */\nvar ErrorHandler;\nexport { ErrorHandler };\n/**\n * @param {?} error\n * @return {?}\n */\nfunction defaultErrorHandler(error) {\n    throw error;\n}\n/**\n * @param {?} error\n * @param {?} urlSerializer\n * @param {?} url\n * @return {?}\n */\nfunction defaultMalformedUriErrorHandler(error, urlSerializer, url) {\n    return urlSerializer.parse('/');\n}\n/** @typedef {?} */\nvar NavStreamValue;\n/** @typedef {?} */\nvar NavigationParams;\n/** @typedef {?} */\nvar RouterHook;\nexport { RouterHook };\n/**\n * \\@internal\n * @param {?} snapshot\n * @param {?} runExtras\n * @return {?}\n */\nfunction defaultRouterHook(snapshot, runExtras) {\n    return /** @type {?} */ (of(null));\n}\n/**\n * \\@description\n *\n * Provides the navigation and url manipulation capabilities.\n *\n * See `Routes` for more details and examples.\n *\n * \\@ngModule RouterModule\n *\n *\n */\nvar /**\n * \\@description\n *\n * Provides the navigation and url manipulation capabilities.\n *\n * See `Routes` for more details and examples.\n *\n * \\@ngModule RouterModule\n *\n *\n */\nRouter = /** @class */ (function () {\n    /**\n     * Creates the router service.\n     */\n    // TODO: vsavkin make internal after the final is out.\n    function Router(rootComponentType, urlSerializer, rootContexts, location, injector, loader, compiler, config) {\n        var _this = this;\n        this.rootComponentType = rootComponentType;\n        this.urlSerializer = urlSerializer;\n        this.rootContexts = rootContexts;\n        this.location = location;\n        this.config = config;\n        this.navigations = new BehaviorSubject(/** @type {?} */ ((null)));\n        this.navigationId = 0;\n        this.events = new Subject();\n        /**\n         * Error handler that is invoked when a navigation errors.\n         *\n         * See `ErrorHandler` for more information.\n         */\n        this.errorHandler = defaultErrorHandler;\n        /**\n         * Malformed uri error handler is invoked when `Router.parseUrl(url)` throws an\n         * error due to containing an invalid character. The most common case would be a `%` sign\n         * that's not encoded and is not part of a percent encoded sequence.\n         */\n        this.malformedUriErrorHandler = defaultMalformedUriErrorHandler;\n        /**\n         * Indicates if at least one navigation happened.\n         */\n        this.navigated = false;\n        this.lastSuccessfulId = -1;\n        /**\n         * Used by RouterModule. This allows us to\n         * pause the navigation either before preactivation or after it.\n         * \\@internal\n         */\n        this.hooks = {\n            beforePreactivation: defaultRouterHook,\n            afterPreactivation: defaultRouterHook\n        };\n        /**\n         * Extracts and merges URLs. Used for AngularJS to Angular migrations.\n         */\n        this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();\n        this.routeReuseStrategy = new DefaultRouteReuseStrategy();\n        /**\n         * Define what the router should do if it receives a navigation request to the current URL.\n         * By default, the router will ignore this navigation. However, this prevents features such\n         * as a \"refresh\" button. Use this option to configure the behavior when navigating to the\n         * current URL. Default is 'ignore'.\n         */\n        this.onSameUrlNavigation = 'ignore';\n        /**\n         * Defines how the router merges params, data and resolved data from parent to child\n         * routes. Available options are:\n         *\n         * - `'emptyOnly'`, the default, only inherits parent params for path-less or component-less\n         *   routes.\n         * - `'always'`, enables unconditional inheritance of parent params.\n         */\n        this.paramsInheritanceStrategy = 'emptyOnly';\n        /**\n         * Defines when the router updates the browser URL. The default behavior is to update after\n         * successful navigation. However, some applications may prefer a mode where the URL gets\n         * updated at the beginning of navigation. The most common use case would be updating the\n         * URL early so if navigation fails, you can show an error message with the URL that failed.\n         * Available options are:\n         *\n         * - `'deferred'`, the default, updates the browser URL after navigation has finished.\n         * - `'eager'`, updates browser URL at the beginning of navigation.\n         */\n        this.urlUpdateStrategy = 'deferred';\n        /**\n         * See {\\@link RouterModule} for more information.\n         */\n        this.relativeLinkResolution = 'legacy';\n        /** @type {?} */\n        var onLoadStart = function (r) { return _this.triggerEvent(new RouteConfigLoadStart(r)); };\n        /** @type {?} */\n        var onLoadEnd = function (r) { return _this.triggerEvent(new RouteConfigLoadEnd(r)); };\n        this.ngModule = injector.get(NgModuleRef);\n        this.resetConfig(config);\n        this.currentUrlTree = createEmptyUrlTree();\n        this.rawUrlTree = this.currentUrlTree;\n        this.configLoader = new RouterConfigLoader(loader, compiler, onLoadStart, onLoadEnd);\n        this.routerState = createEmptyState(this.currentUrlTree, this.rootComponentType);\n        this.processNavigations();\n    }\n    /**\n     * @internal\n     * TODO: this should be removed once the constructor of the router made internal\n     */\n    /**\n     * \\@internal\n     * TODO: this should be removed once the constructor of the router made internal\n     * @param {?} rootComponentType\n     * @return {?}\n     */\n    Router.prototype.resetRootComponentType = /**\n     * \\@internal\n     * TODO: this should be removed once the constructor of the router made internal\n     * @param {?} rootComponentType\n     * @return {?}\n     */\n    function (rootComponentType) {\n        this.rootComponentType = rootComponentType;\n        // TODO: vsavkin router 4.0 should make the root component set to null\n        // this will simplify the lifecycle of the router.\n        this.routerState.root.component = this.rootComponentType;\n    };\n    /**\n     * Sets up the location change listener and performs the initial navigation.\n     */\n    /**\n     * Sets up the location change listener and performs the initial navigation.\n     * @return {?}\n     */\n    Router.prototype.initialNavigation = /**\n     * Sets up the location change listener and performs the initial navigation.\n     * @return {?}\n     */\n    function () {\n        this.setUpLocationChangeListener();\n        if (this.navigationId === 0) {\n            this.navigateByUrl(this.location.path(true), { replaceUrl: true });\n        }\n    };\n    /**\n     * Sets up the location change listener.\n     */\n    /**\n     * Sets up the location change listener.\n     * @return {?}\n     */\n    Router.prototype.setUpLocationChangeListener = /**\n     * Sets up the location change listener.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Don't need to use Zone.wrap any more, because zone.js\n        // already patch onPopState, so location change callback will\n        // run into ngZone\n        if (!this.locationSubscription) {\n            this.locationSubscription = /** @type {?} */ (this.location.subscribe(function (change) {\n                /** @type {?} */\n                var rawUrlTree = _this.parseUrl(change['url']);\n                /** @type {?} */\n                var source = change['type'] === 'popstate' ? 'popstate' : 'hashchange';\n                /** @type {?} */\n                var state = change.state && change.state.navigationId ?\n                    { navigationId: change.state.navigationId } :\n                    null;\n                setTimeout(function () { _this.scheduleNavigation(rawUrlTree, source, state, { replaceUrl: true }); }, 0);\n            }));\n        }\n    };\n    Object.defineProperty(Router.prototype, \"url\", {\n        /** The current url */\n        get: /**\n         * The current url\n         * @return {?}\n         */\n        function () { return this.serializeUrl(this.currentUrlTree); },\n        enumerable: true,\n        configurable: true\n    });\n    /** @internal */\n    /**\n     * \\@internal\n     * @param {?} e\n     * @return {?}\n     */\n    Router.prototype.triggerEvent = /**\n     * \\@internal\n     * @param {?} e\n     * @return {?}\n     */\n    function (e) { (/** @type {?} */ (this.events)).next(e); };\n    /**\n     * Resets the configuration used for navigation and generating links.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.resetConfig([\n     *  { path: 'team/:id', component: TeamCmp, children: [\n     *    { path: 'simple', component: SimpleCmp },\n     *    { path: 'user/:name', component: UserCmp }\n     *  ]}\n     * ]);\n     * ```\n     */\n    /**\n     * Resets the configuration used for navigation and generating links.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.resetConfig([\n     *  { path: 'team/:id', component: TeamCmp, children: [\n     *    { path: 'simple', component: SimpleCmp },\n     *    { path: 'user/:name', component: UserCmp }\n     *  ]}\n     * ]);\n     * ```\n     * @param {?} config\n     * @return {?}\n     */\n    Router.prototype.resetConfig = /**\n     * Resets the configuration used for navigation and generating links.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.resetConfig([\n     *  { path: 'team/:id', component: TeamCmp, children: [\n     *    { path: 'simple', component: SimpleCmp },\n     *    { path: 'user/:name', component: UserCmp }\n     *  ]}\n     * ]);\n     * ```\n     * @param {?} config\n     * @return {?}\n     */\n    function (config) {\n        validateConfig(config);\n        this.config = config.map(standardizeConfig);\n        this.navigated = false;\n        this.lastSuccessfulId = -1;\n    };\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    Router.prototype.ngOnDestroy = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () { this.dispose(); };\n    /** Disposes of the router */\n    /**\n     * Disposes of the router\n     * @return {?}\n     */\n    Router.prototype.dispose = /**\n     * Disposes of the router\n     * @return {?}\n     */\n    function () {\n        if (this.locationSubscription) {\n            this.locationSubscription.unsubscribe();\n            this.locationSubscription = /** @type {?} */ ((null));\n        }\n    };\n    /**\n     * Applies an array of commands to the current url tree and creates a new url tree.\n     *\n     * When given an activate route, applies the given commands starting from the route.\n     * When not given a route, applies the given command starting from the root.\n     *\n     * ### Usage\n     *\n     * ```\n     * // create /team/33/user/11\n     * router.createUrlTree(['/team', 33, 'user', 11]);\n     *\n     * // create /team/33;expand=true/user/11\n     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n     *\n     * // you can collapse static segments like this (this works only with the first passed-in value):\n     * router.createUrlTree(['/team/33/user', userId]);\n     *\n     * // If the first segment can contain slashes, and you do not want the router to split it, you\n     * // can do the following:\n     *\n     * router.createUrlTree([{segmentPath: '/one/two'}]);\n     *\n     * // create /team/33/(user/11//right:chat)\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n     *\n     * // remove the right secondary node\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n     *\n     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n     *\n     * // navigate to /team/33/user/11/details\n     * router.createUrlTree(['details'], {relativeTo: route});\n     *\n     * // navigate to /team/33/user/22\n     * router.createUrlTree(['../22'], {relativeTo: route});\n     *\n     * // navigate to /team/44/user/22\n     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n     * ```\n     */\n    /**\n     * Applies an array of commands to the current url tree and creates a new url tree.\n     *\n     * When given an activate route, applies the given commands starting from the route.\n     * When not given a route, applies the given command starting from the root.\n     *\n     * ### Usage\n     *\n     * ```\n     * // create /team/33/user/11\n     * router.createUrlTree(['/team', 33, 'user', 11]);\n     *\n     * // create /team/33;expand=true/user/11\n     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n     *\n     * // you can collapse static segments like this (this works only with the first passed-in value):\n     * router.createUrlTree(['/team/33/user', userId]);\n     *\n     * // If the first segment can contain slashes, and you do not want the router to split it, you\n     * // can do the following:\n     *\n     * router.createUrlTree([{segmentPath: '/one/two'}]);\n     *\n     * // create /team/33/(user/11//right:chat)\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n     *\n     * // remove the right secondary node\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n     *\n     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n     *\n     * // navigate to /team/33/user/11/details\n     * router.createUrlTree(['details'], {relativeTo: route});\n     *\n     * // navigate to /team/33/user/22\n     * router.createUrlTree(['../22'], {relativeTo: route});\n     *\n     * // navigate to /team/44/user/22\n     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n     * ```\n     * @param {?} commands\n     * @param {?=} navigationExtras\n     * @return {?}\n     */\n    Router.prototype.createUrlTree = /**\n     * Applies an array of commands to the current url tree and creates a new url tree.\n     *\n     * When given an activate route, applies the given commands starting from the route.\n     * When not given a route, applies the given command starting from the root.\n     *\n     * ### Usage\n     *\n     * ```\n     * // create /team/33/user/11\n     * router.createUrlTree(['/team', 33, 'user', 11]);\n     *\n     * // create /team/33;expand=true/user/11\n     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n     *\n     * // you can collapse static segments like this (this works only with the first passed-in value):\n     * router.createUrlTree(['/team/33/user', userId]);\n     *\n     * // If the first segment can contain slashes, and you do not want the router to split it, you\n     * // can do the following:\n     *\n     * router.createUrlTree([{segmentPath: '/one/two'}]);\n     *\n     * // create /team/33/(user/11//right:chat)\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n     *\n     * // remove the right secondary node\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n     *\n     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n     *\n     * // navigate to /team/33/user/11/details\n     * router.createUrlTree(['details'], {relativeTo: route});\n     *\n     * // navigate to /team/33/user/22\n     * router.createUrlTree(['../22'], {relativeTo: route});\n     *\n     * // navigate to /team/44/user/22\n     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n     * ```\n     * @param {?} commands\n     * @param {?=} navigationExtras\n     * @return {?}\n     */\n    function (commands, navigationExtras) {\n        if (navigationExtras === void 0) { navigationExtras = {}; }\n        var relativeTo = navigationExtras.relativeTo, queryParams = navigationExtras.queryParams, fragment = navigationExtras.fragment, preserveQueryParams = navigationExtras.preserveQueryParams, queryParamsHandling = navigationExtras.queryParamsHandling, preserveFragment = navigationExtras.preserveFragment;\n        if (isDevMode() && preserveQueryParams && /** @type {?} */ (console) && /** @type {?} */ (console.warn)) {\n            console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');\n        }\n        /** @type {?} */\n        var a = relativeTo || this.routerState.root;\n        /** @type {?} */\n        var f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n        /** @type {?} */\n        var q = null;\n        if (queryParamsHandling) {\n            switch (queryParamsHandling) {\n                case 'merge':\n                    q = tslib_1.__assign({}, this.currentUrlTree.queryParams, queryParams);\n                    break;\n                case 'preserve':\n                    q = this.currentUrlTree.queryParams;\n                    break;\n                default:\n                    q = queryParams || null;\n            }\n        }\n        else {\n            q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams || null;\n        }\n        if (q !== null) {\n            q = this.removeEmptyProps(q);\n        }\n        return createUrlTree(a, this.currentUrlTree, commands, /** @type {?} */ ((q)), /** @type {?} */ ((f)));\n    };\n    /**\n     * Navigate based on the provided url. This navigation is always absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.navigateByUrl(\"/team/33/user/11\");\n     *\n     * // Navigate without updating the URL\n     * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n     * ```\n     *\n     * In opposite to `navigate`, `navigateByUrl` takes a whole URL\n     * and does not apply any delta to the current one.\n     */\n    /**\n     * Navigate based on the provided url. This navigation is always absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.navigateByUrl(\"/team/33/user/11\");\n     *\n     * // Navigate without updating the URL\n     * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n     * ```\n     *\n     * In opposite to `navigate`, `navigateByUrl` takes a whole URL\n     * and does not apply any delta to the current one.\n     * @param {?} url\n     * @param {?=} extras\n     * @return {?}\n     */\n    Router.prototype.navigateByUrl = /**\n     * Navigate based on the provided url. This navigation is always absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.navigateByUrl(\"/team/33/user/11\");\n     *\n     * // Navigate without updating the URL\n     * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n     * ```\n     *\n     * In opposite to `navigate`, `navigateByUrl` takes a whole URL\n     * and does not apply any delta to the current one.\n     * @param {?} url\n     * @param {?=} extras\n     * @return {?}\n     */\n    function (url, extras) {\n        if (extras === void 0) { extras = { skipLocationChange: false }; }\n        /** @type {?} */\n        var urlTree = url instanceof UrlTree ? url : this.parseUrl(url);\n        /** @type {?} */\n        var mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n        return this.scheduleNavigation(mergedTree, 'imperative', null, extras);\n    };\n    /**\n     * Navigate based on the provided array of commands and a starting point.\n     * If no starting route is provided, the navigation is absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n     *\n     * // Navigate without updating the URL\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n     * ```\n     *\n     * In opposite to `navigateByUrl`, `navigate` always takes a delta that is applied to the current\n     * URL.\n     */\n    /**\n     * Navigate based on the provided array of commands and a starting point.\n     * If no starting route is provided, the navigation is absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n     *\n     * // Navigate without updating the URL\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n     * ```\n     *\n     * In opposite to `navigateByUrl`, `navigate` always takes a delta that is applied to the current\n     * URL.\n     * @param {?} commands\n     * @param {?=} extras\n     * @return {?}\n     */\n    Router.prototype.navigate = /**\n     * Navigate based on the provided array of commands and a starting point.\n     * If no starting route is provided, the navigation is absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n     *\n     * // Navigate without updating the URL\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n     * ```\n     *\n     * In opposite to `navigateByUrl`, `navigate` always takes a delta that is applied to the current\n     * URL.\n     * @param {?} commands\n     * @param {?=} extras\n     * @return {?}\n     */\n    function (commands, extras) {\n        if (extras === void 0) { extras = { skipLocationChange: false }; }\n        validateCommands(commands);\n        return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n    };\n    /** Serializes a `UrlTree` into a string */\n    /**\n     * Serializes a `UrlTree` into a string\n     * @param {?} url\n     * @return {?}\n     */\n    Router.prototype.serializeUrl = /**\n     * Serializes a `UrlTree` into a string\n     * @param {?} url\n     * @return {?}\n     */\n    function (url) { return this.urlSerializer.serialize(url); };\n    /** Parses a string into a `UrlTree` */\n    /**\n     * Parses a string into a `UrlTree`\n     * @param {?} url\n     * @return {?}\n     */\n    Router.prototype.parseUrl = /**\n     * Parses a string into a `UrlTree`\n     * @param {?} url\n     * @return {?}\n     */\n    function (url) {\n        /** @type {?} */\n        var urlTree;\n        try {\n            urlTree = this.urlSerializer.parse(url);\n        }\n        catch (e) {\n            urlTree = this.malformedUriErrorHandler(e, this.urlSerializer, url);\n        }\n        return urlTree;\n    };\n    /** Returns whether the url is activated */\n    /**\n     * Returns whether the url is activated\n     * @param {?} url\n     * @param {?} exact\n     * @return {?}\n     */\n    Router.prototype.isActive = /**\n     * Returns whether the url is activated\n     * @param {?} url\n     * @param {?} exact\n     * @return {?}\n     */\n    function (url, exact) {\n        if (url instanceof UrlTree) {\n            return containsTree(this.currentUrlTree, url, exact);\n        }\n        /** @type {?} */\n        var urlTree = this.parseUrl(url);\n        return containsTree(this.currentUrlTree, urlTree, exact);\n    };\n    /**\n     * @param {?} params\n     * @return {?}\n     */\n    Router.prototype.removeEmptyProps = /**\n     * @param {?} params\n     * @return {?}\n     */\n    function (params) {\n        return Object.keys(params).reduce(function (result, key) {\n            /** @type {?} */\n            var value = params[key];\n            if (value !== null && value !== undefined) {\n                result[key] = value;\n            }\n            return result;\n        }, {});\n    };\n    /**\n     * @return {?}\n     */\n    Router.prototype.processNavigations = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this.navigations\n            .pipe(concatMap(function (nav) {\n            if (nav) {\n                _this.executeScheduledNavigation(nav);\n                // a failed navigation should not stop the router from processing\n                // further navigations => the catch\n                return nav.promise.catch(function () { });\n            }\n            else {\n                return /** @type {?} */ (of(null));\n            }\n        }))\n            .subscribe(function () { });\n    };\n    /**\n     * @param {?} rawUrl\n     * @param {?} source\n     * @param {?} state\n     * @param {?} extras\n     * @return {?}\n     */\n    Router.prototype.scheduleNavigation = /**\n     * @param {?} rawUrl\n     * @param {?} source\n     * @param {?} state\n     * @param {?} extras\n     * @return {?}\n     */\n    function (rawUrl, source, state, extras) {\n        /** @type {?} */\n        var lastNavigation = this.navigations.value;\n        // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),\n        // and that navigation results in 'replaceState' that leads to the same URL,\n        // we should skip those.\n        if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' &&\n            lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n            return Promise.resolve(true); // return value is not used\n        }\n        // Because of a bug in IE and Edge, the location class fires two events (popstate and\n        // hashchange) every single time. The second one should be ignored. Otherwise, the URL will\n        // flicker. Handles the case when a popstate was emitted first.\n        if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' &&\n            lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n            return Promise.resolve(true); // return value is not used\n        }\n        // Because of a bug in IE and Edge, the location class fires two events (popstate and\n        // hashchange) every single time. The second one should be ignored. Otherwise, the URL will\n        // flicker. Handles the case when a hashchange was emitted first.\n        if (lastNavigation && source == 'popstate' && lastNavigation.source === 'hashchange' &&\n            lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n            return Promise.resolve(true); // return value is not used\n        }\n        /** @type {?} */\n        var resolve = null;\n        /** @type {?} */\n        var reject = null;\n        /** @type {?} */\n        var promise = new Promise(function (res, rej) {\n            resolve = res;\n            reject = rej;\n        });\n        /** @type {?} */\n        var id = ++this.navigationId;\n        this.navigations.next({ id: id, source: source, state: state, rawUrl: rawUrl, extras: extras, resolve: resolve, reject: reject, promise: promise });\n        // Make sure that the error is propagated even though `processNavigations` catch\n        // handler does not rethrow\n        return promise.catch(function (e) { return Promise.reject(e); });\n    };\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    Router.prototype.executeScheduledNavigation = /**\n     * @param {?} __0\n     * @return {?}\n     */\n    function (_a) {\n        var _this = this;\n        var id = _a.id, rawUrl = _a.rawUrl, extras = _a.extras, resolve = _a.resolve, reject = _a.reject, source = _a.source, state = _a.state;\n        /** @type {?} */\n        var url = this.urlHandlingStrategy.extract(rawUrl);\n        /** @type {?} */\n        var urlTransition = !this.navigated || url.toString() !== this.currentUrlTree.toString();\n        if ((this.onSameUrlNavigation === 'reload' ? true : urlTransition) &&\n            this.urlHandlingStrategy.shouldProcessUrl(rawUrl)) {\n            if (this.urlUpdateStrategy === 'eager' && !extras.skipLocationChange) {\n                this.setBrowserUrl(rawUrl, !!extras.replaceUrl, id);\n            }\n            (/** @type {?} */ (this.events))\n                .next(new NavigationStart(id, this.serializeUrl(url), source, state));\n            Promise.resolve()\n                .then(function (_) { return _this.runNavigate(url, rawUrl, !!extras.skipLocationChange, !!extras.replaceUrl, id, null); })\n                .then(resolve, reject);\n            // we cannot process the current URL, but we could process the previous one =>\n            // we need to do some cleanup\n        }\n        else if (urlTransition && this.rawUrlTree &&\n            this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) {\n            (/** @type {?} */ (this.events))\n                .next(new NavigationStart(id, this.serializeUrl(url), source, state));\n            Promise.resolve()\n                .then(function (_) { return _this.runNavigate(url, rawUrl, false, false, id, createEmptyState(url, _this.rootComponentType).snapshot); })\n                .then(resolve, reject);\n        }\n        else {\n            this.rawUrlTree = rawUrl;\n            resolve(null);\n        }\n    };\n    /**\n     * @param {?} url\n     * @param {?} rawUrl\n     * @param {?} skipLocationChange\n     * @param {?} replaceUrl\n     * @param {?} id\n     * @param {?} precreatedState\n     * @return {?}\n     */\n    Router.prototype.runNavigate = /**\n     * @param {?} url\n     * @param {?} rawUrl\n     * @param {?} skipLocationChange\n     * @param {?} replaceUrl\n     * @param {?} id\n     * @param {?} precreatedState\n     * @return {?}\n     */\n    function (url, rawUrl, skipLocationChange, replaceUrl, id, precreatedState) {\n        var _this = this;\n        if (id !== this.navigationId) {\n            (/** @type {?} */ (this.events))\n                .next(new NavigationCancel(id, this.serializeUrl(url), \"Navigation ID \" + id + \" is not equal to the current navigation id \" + this.navigationId));\n            return Promise.resolve(false);\n        }\n        return new Promise(function (resolvePromise, rejectPromise) {\n            /** @type {?} */\n            var urlAndSnapshot$;\n            if (!precreatedState) {\n                /** @type {?} */\n                var moduleInjector = _this.ngModule.injector;\n                /** @type {?} */\n                var redirectsApplied$ = applyRedirects(moduleInjector, _this.configLoader, _this.urlSerializer, url, _this.config);\n                urlAndSnapshot$ = redirectsApplied$.pipe(mergeMap(function (appliedUrl) {\n                    return recognize(_this.rootComponentType, _this.config, appliedUrl, _this.serializeUrl(appliedUrl), _this.paramsInheritanceStrategy, _this.relativeLinkResolution)\n                        .pipe(map(function (snapshot) {\n                        (/** @type {?} */ (_this.events))\n                            .next(new RoutesRecognized(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl), snapshot));\n                        return { appliedUrl: appliedUrl, snapshot: snapshot };\n                    }));\n                }));\n            }\n            else {\n                urlAndSnapshot$ = of({ appliedUrl: url, snapshot: precreatedState });\n            }\n            /** @type {?} */\n            var beforePreactivationDone$ = urlAndSnapshot$.pipe(mergeMap(function (p) {\n                if (typeof p === 'boolean')\n                    return of(p);\n                return _this.hooks\n                    .beforePreactivation(p.snapshot, {\n                    navigationId: id,\n                    appliedUrlTree: url,\n                    rawUrlTree: rawUrl, skipLocationChange: skipLocationChange, replaceUrl: replaceUrl,\n                })\n                    .pipe(map(function () { return p; }));\n            }));\n            /** @type {?} */\n            var preActivation;\n            /** @type {?} */\n            var preactivationSetup$ = beforePreactivationDone$.pipe(map(function (p) {\n                if (typeof p === 'boolean')\n                    return p;\n                var appliedUrl = p.appliedUrl, snapshot = p.snapshot;\n                /** @type {?} */\n                var moduleInjector = _this.ngModule.injector;\n                preActivation = new PreActivation(snapshot, _this.routerState.snapshot, moduleInjector, function (evt) { return _this.triggerEvent(evt); });\n                preActivation.initialize(_this.rootContexts);\n                return { appliedUrl: appliedUrl, snapshot: snapshot };\n            }));\n            /** @type {?} */\n            var preactivationCheckGuards$ = preactivationSetup$.pipe(mergeMap(function (p) {\n                if (typeof p === 'boolean' || _this.navigationId !== id)\n                    return of(false);\n                var appliedUrl = p.appliedUrl, snapshot = p.snapshot;\n                _this.triggerEvent(new GuardsCheckStart(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl), snapshot));\n                return preActivation.checkGuards().pipe(map(function (shouldActivate) {\n                    _this.triggerEvent(new GuardsCheckEnd(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl), snapshot, shouldActivate));\n                    return { appliedUrl: appliedUrl, snapshot: snapshot, shouldActivate: shouldActivate };\n                }));\n            }));\n            /** @type {?} */\n            var preactivationResolveData$ = preactivationCheckGuards$.pipe(mergeMap(function (p) {\n                if (typeof p === 'boolean' || _this.navigationId !== id)\n                    return of(false);\n                if (p.shouldActivate && preActivation.isActivating()) {\n                    _this.triggerEvent(new ResolveStart(id, _this.serializeUrl(url), _this.serializeUrl(p.appliedUrl), p.snapshot));\n                    return preActivation.resolveData(_this.paramsInheritanceStrategy).pipe(map(function () {\n                        _this.triggerEvent(new ResolveEnd(id, _this.serializeUrl(url), _this.serializeUrl(p.appliedUrl), p.snapshot));\n                        return p;\n                    }));\n                }\n                else {\n                    return of(p);\n                }\n            }));\n            /** @type {?} */\n            var preactivationDone$ = preactivationResolveData$.pipe(mergeMap(function (p) {\n                if (typeof p === 'boolean' || _this.navigationId !== id)\n                    return of(false);\n                return _this.hooks\n                    .afterPreactivation(p.snapshot, {\n                    navigationId: id,\n                    appliedUrlTree: url,\n                    rawUrlTree: rawUrl, skipLocationChange: skipLocationChange, replaceUrl: replaceUrl,\n                })\n                    .pipe(map(function () { return p; }));\n            }));\n            /** @type {?} */\n            var routerState$ = preactivationDone$.pipe(map(function (p) {\n                if (typeof p === 'boolean' || _this.navigationId !== id)\n                    return false;\n                var appliedUrl = p.appliedUrl, snapshot = p.snapshot, shouldActivate = p.shouldActivate;\n                if (shouldActivate) {\n                    /** @type {?} */\n                    var state = createRouterState(_this.routeReuseStrategy, snapshot, _this.routerState);\n                    return { appliedUrl: appliedUrl, state: state, shouldActivate: shouldActivate };\n                }\n                else {\n                    return { appliedUrl: appliedUrl, state: null, shouldActivate: shouldActivate };\n                }\n            }));\n            _this.activateRoutes(routerState$, _this.routerState, _this.currentUrlTree, id, url, rawUrl, skipLocationChange, replaceUrl, resolvePromise, rejectPromise);\n        });\n    };\n    /**\n     * Performs the logic of activating routes. This is a synchronous process by default. While this\n     * is a private method, it could be overridden to make activation asynchronous.\n     * @param {?} state\n     * @param {?} storedState\n     * @param {?} storedUrl\n     * @param {?} id\n     * @param {?} url\n     * @param {?} rawUrl\n     * @param {?} skipLocationChange\n     * @param {?} replaceUrl\n     * @param {?} resolvePromise\n     * @param {?} rejectPromise\n     * @return {?}\n     */\n    Router.prototype.activateRoutes = /**\n     * Performs the logic of activating routes. This is a synchronous process by default. While this\n     * is a private method, it could be overridden to make activation asynchronous.\n     * @param {?} state\n     * @param {?} storedState\n     * @param {?} storedUrl\n     * @param {?} id\n     * @param {?} url\n     * @param {?} rawUrl\n     * @param {?} skipLocationChange\n     * @param {?} replaceUrl\n     * @param {?} resolvePromise\n     * @param {?} rejectPromise\n     * @return {?}\n     */\n    function (state, storedState, storedUrl, id, url, rawUrl, skipLocationChange, replaceUrl, resolvePromise, rejectPromise) {\n        var _this = this;\n        /** @type {?} */\n        var navigationIsSuccessful;\n        state\n            .forEach(function (p) {\n            if (typeof p === 'boolean' || !p.shouldActivate || id !== _this.navigationId || !p.state) {\n                navigationIsSuccessful = false;\n                return;\n            }\n            var appliedUrl = p.appliedUrl, state = p.state;\n            _this.currentUrlTree = appliedUrl;\n            _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);\n            (/** @type {?} */ (_this)).routerState = state;\n            if (_this.urlUpdateStrategy === 'deferred' && !skipLocationChange) {\n                _this.setBrowserUrl(_this.rawUrlTree, replaceUrl, id);\n            }\n            new ActivateRoutes(_this.routeReuseStrategy, state, storedState, function (evt) { return _this.triggerEvent(evt); })\n                .activate(_this.rootContexts);\n            navigationIsSuccessful = true;\n        })\n            .then(function () {\n            if (navigationIsSuccessful) {\n                _this.navigated = true;\n                _this.lastSuccessfulId = id;\n                (/** @type {?} */ (_this.events))\n                    .next(new NavigationEnd(id, _this.serializeUrl(url), _this.serializeUrl(_this.currentUrlTree)));\n                resolvePromise(true);\n            }\n            else {\n                _this.resetUrlToCurrentUrlTree();\n                (/** @type {?} */ (_this.events))\n                    .next(new NavigationCancel(id, _this.serializeUrl(url), ''));\n                resolvePromise(false);\n            }\n        }, function (e) {\n            if (isNavigationCancelingError(e)) {\n                _this.navigated = true;\n                _this.resetStateAndUrl(storedState, storedUrl, rawUrl);\n                (/** @type {?} */ (_this.events))\n                    .next(new NavigationCancel(id, _this.serializeUrl(url), e.message));\n                resolvePromise(false);\n            }\n            else {\n                _this.resetStateAndUrl(storedState, storedUrl, rawUrl);\n                (/** @type {?} */ (_this.events))\n                    .next(new NavigationError(id, _this.serializeUrl(url), e));\n                try {\n                    resolvePromise(_this.errorHandler(e));\n                }\n                catch (ee) {\n                    rejectPromise(ee);\n                }\n            }\n        });\n    };\n    /**\n     * @param {?} url\n     * @param {?} replaceUrl\n     * @param {?} id\n     * @return {?}\n     */\n    Router.prototype.setBrowserUrl = /**\n     * @param {?} url\n     * @param {?} replaceUrl\n     * @param {?} id\n     * @return {?}\n     */\n    function (url, replaceUrl, id) {\n        /** @type {?} */\n        var path = this.urlSerializer.serialize(url);\n        if (this.location.isCurrentPathEqualTo(path) || replaceUrl) {\n            this.location.replaceState(path, '', { navigationId: id });\n        }\n        else {\n            this.location.go(path, '', { navigationId: id });\n        }\n    };\n    /**\n     * @param {?} storedState\n     * @param {?} storedUrl\n     * @param {?} rawUrl\n     * @return {?}\n     */\n    Router.prototype.resetStateAndUrl = /**\n     * @param {?} storedState\n     * @param {?} storedUrl\n     * @param {?} rawUrl\n     * @return {?}\n     */\n    function (storedState, storedUrl, rawUrl) {\n        (/** @type {?} */ (this)).routerState = storedState;\n        this.currentUrlTree = storedUrl;\n        this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, rawUrl);\n        this.resetUrlToCurrentUrlTree();\n    };\n    /**\n     * @return {?}\n     */\n    Router.prototype.resetUrlToCurrentUrlTree = /**\n     * @return {?}\n     */\n    function () {\n        this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), '', { navigationId: this.lastSuccessfulId });\n    };\n    return Router;\n}());\n/**\n * \\@description\n *\n * Provides the navigation and url manipulation capabilities.\n *\n * See `Routes` for more details and examples.\n *\n * \\@ngModule RouterModule\n *\n *\n */\nexport { Router };\nif (false) {\n    /** @type {?} */\n    Router.prototype.currentUrlTree;\n    /** @type {?} */\n    Router.prototype.rawUrlTree;\n    /** @type {?} */\n    Router.prototype.navigations;\n    /** @type {?} */\n    Router.prototype.locationSubscription;\n    /** @type {?} */\n    Router.prototype.navigationId;\n    /** @type {?} */\n    Router.prototype.configLoader;\n    /** @type {?} */\n    Router.prototype.ngModule;\n    /** @type {?} */\n    Router.prototype.events;\n    /** @type {?} */\n    Router.prototype.routerState;\n    /**\n     * Error handler that is invoked when a navigation errors.\n     *\n     * See `ErrorHandler` for more information.\n     * @type {?}\n     */\n    Router.prototype.errorHandler;\n    /**\n     * Malformed uri error handler is invoked when `Router.parseUrl(url)` throws an\n     * error due to containing an invalid character. The most common case would be a `%` sign\n     * that's not encoded and is not part of a percent encoded sequence.\n     * @type {?}\n     */\n    Router.prototype.malformedUriErrorHandler;\n    /**\n     * Indicates if at least one navigation happened.\n     * @type {?}\n     */\n    Router.prototype.navigated;\n    /** @type {?} */\n    Router.prototype.lastSuccessfulId;\n    /**\n     * Used by RouterModule. This allows us to\n     * pause the navigation either before preactivation or after it.\n     * \\@internal\n     * @type {?}\n     */\n    Router.prototype.hooks;\n    /**\n     * Extracts and merges URLs. Used for AngularJS to Angular migrations.\n     * @type {?}\n     */\n    Router.prototype.urlHandlingStrategy;\n    /** @type {?} */\n    Router.prototype.routeReuseStrategy;\n    /**\n     * Define what the router should do if it receives a navigation request to the current URL.\n     * By default, the router will ignore this navigation. However, this prevents features such\n     * as a \"refresh\" button. Use this option to configure the behavior when navigating to the\n     * current URL. Default is 'ignore'.\n     * @type {?}\n     */\n    Router.prototype.onSameUrlNavigation;\n    /**\n     * Defines how the router merges params, data and resolved data from parent to child\n     * routes. Available options are:\n     *\n     * - `'emptyOnly'`, the default, only inherits parent params for path-less or component-less\n     *   routes.\n     * - `'always'`, enables unconditional inheritance of parent params.\n     * @type {?}\n     */\n    Router.prototype.paramsInheritanceStrategy;\n    /**\n     * Defines when the router updates the browser URL. The default behavior is to update after\n     * successful navigation. However, some applications may prefer a mode where the URL gets\n     * updated at the beginning of navigation. The most common use case would be updating the\n     * URL early so if navigation fails, you can show an error message with the URL that failed.\n     * Available options are:\n     *\n     * - `'deferred'`, the default, updates the browser URL after navigation has finished.\n     * - `'eager'`, updates browser URL at the beginning of navigation.\n     * @type {?}\n     */\n    Router.prototype.urlUpdateStrategy;\n    /**\n     * See {\\@link RouterModule} for more information.\n     * @type {?}\n     */\n    Router.prototype.relativeLinkResolution;\n    /** @type {?} */\n    Router.prototype.rootComponentType;\n    /** @type {?} */\n    Router.prototype.urlSerializer;\n    /** @type {?} */\n    Router.prototype.rootContexts;\n    /** @type {?} */\n    Router.prototype.location;\n    /** @type {?} */\n    Router.prototype.config;\n}\nvar ActivateRoutes = /** @class */ (function () {\n    function ActivateRoutes(routeReuseStrategy, futureState, currState, forwardEvent) {\n        this.routeReuseStrategy = routeReuseStrategy;\n        this.futureState = futureState;\n        this.currState = currState;\n        this.forwardEvent = forwardEvent;\n    }\n    /**\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.activate = /**\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    function (parentContexts) {\n        /** @type {?} */\n        var futureRoot = this.futureState._root;\n        /** @type {?} */\n        var currRoot = this.currState ? this.currState._root : null;\n        this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n        advanceActivatedRoute(this.futureState.root);\n        this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n    };\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.deactivateChildRoutes = /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @return {?}\n     */\n    function (futureNode, currNode, contexts) {\n        var _this = this;\n        /** @type {?} */\n        var children = nodeChildrenAsMap(currNode);\n        // Recurse on the routes active in the future state to de-activate deeper children\n        futureNode.children.forEach(function (futureChild) {\n            /** @type {?} */\n            var childOutletName = futureChild.value.outlet;\n            _this.deactivateRoutes(futureChild, children[childOutletName], contexts);\n            delete children[childOutletName];\n        });\n        // De-activate the routes that will not be re-used\n        forEach(children, function (v, childName) {\n            _this.deactivateRouteAndItsChildren(v, contexts);\n        });\n    };\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContext\n     * @return {?}\n     */\n    ActivateRoutes.prototype.deactivateRoutes = /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContext\n     * @return {?}\n     */\n    function (futureNode, currNode, parentContext) {\n        /** @type {?} */\n        var future = futureNode.value;\n        /** @type {?} */\n        var curr = currNode ? currNode.value : null;\n        if (future === curr) {\n            // Reusing the node, check to see if the children need to be de-activated\n            if (future.component) {\n                /** @type {?} */\n                var context = parentContext.getContext(future.outlet);\n                if (context) {\n                    this.deactivateChildRoutes(futureNode, currNode, context.children);\n                }\n            }\n            else {\n                // if we have a componentless route, we recurse but keep the same outlet map.\n                this.deactivateChildRoutes(futureNode, currNode, parentContext);\n            }\n        }\n        else {\n            if (curr) {\n                // Deactivate the current route which will not be re-used\n                this.deactivateRouteAndItsChildren(currNode, parentContext);\n            }\n        }\n    };\n    /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.deactivateRouteAndItsChildren = /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    function (route, parentContexts) {\n        if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n            this.detachAndStoreRouteSubtree(route, parentContexts);\n        }\n        else {\n            this.deactivateRouteAndOutlet(route, parentContexts);\n        }\n    };\n    /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.detachAndStoreRouteSubtree = /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    function (route, parentContexts) {\n        /** @type {?} */\n        var context = parentContexts.getContext(route.value.outlet);\n        if (context && context.outlet) {\n            /** @type {?} */\n            var componentRef = context.outlet.detach();\n            /** @type {?} */\n            var contexts = context.children.onOutletDeactivated();\n            this.routeReuseStrategy.store(route.value.snapshot, { componentRef: componentRef, route: route, contexts: contexts });\n        }\n    };\n    /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.deactivateRouteAndOutlet = /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    function (route, parentContexts) {\n        var _this = this;\n        /** @type {?} */\n        var context = parentContexts.getContext(route.value.outlet);\n        if (context) {\n            /** @type {?} */\n            var children = nodeChildrenAsMap(route);\n            /** @type {?} */\n            var contexts_1 = route.value.component ? context.children : parentContexts;\n            forEach(children, function (v, k) { return _this.deactivateRouteAndItsChildren(v, contexts_1); });\n            if (context.outlet) {\n                // Destroy the component\n                context.outlet.deactivate();\n                // Destroy the contexts for all the outlets that were in the component\n                context.children.onOutletDeactivated();\n            }\n        }\n    };\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.activateChildRoutes = /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @return {?}\n     */\n    function (futureNode, currNode, contexts) {\n        var _this = this;\n        /** @type {?} */\n        var children = nodeChildrenAsMap(currNode);\n        futureNode.children.forEach(function (c) {\n            _this.activateRoutes(c, children[c.value.outlet], contexts);\n            _this.forwardEvent(new ActivationEnd(c.value.snapshot));\n        });\n        if (futureNode.children.length) {\n            this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n        }\n    };\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.activateRoutes = /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    function (futureNode, currNode, parentContexts) {\n        /** @type {?} */\n        var future = futureNode.value;\n        /** @type {?} */\n        var curr = currNode ? currNode.value : null;\n        advanceActivatedRoute(future);\n        // reusing the node\n        if (future === curr) {\n            if (future.component) {\n                /** @type {?} */\n                var context = parentContexts.getOrCreateContext(future.outlet);\n                this.activateChildRoutes(futureNode, currNode, context.children);\n            }\n            else {\n                // if we have a componentless route, we recurse but keep the same outlet map.\n                this.activateChildRoutes(futureNode, currNode, parentContexts);\n            }\n        }\n        else {\n            if (future.component) {\n                /** @type {?} */\n                var context = parentContexts.getOrCreateContext(future.outlet);\n                if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n                    /** @type {?} */\n                    var stored = (/** @type {?} */ (this.routeReuseStrategy.retrieve(future.snapshot)));\n                    this.routeReuseStrategy.store(future.snapshot, null);\n                    context.children.onOutletReAttached(stored.contexts);\n                    context.attachRef = stored.componentRef;\n                    context.route = stored.route.value;\n                    if (context.outlet) {\n                        // Attach right away when the outlet has already been instantiated\n                        // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\n                        context.outlet.attach(stored.componentRef, stored.route.value);\n                    }\n                    advanceActivatedRouteNodeAndItsChildren(stored.route);\n                }\n                else {\n                    /** @type {?} */\n                    var config = parentLoadedConfig(future.snapshot);\n                    /** @type {?} */\n                    var cmpFactoryResolver = config ? config.module.componentFactoryResolver : null;\n                    context.route = future;\n                    context.resolver = cmpFactoryResolver;\n                    if (context.outlet) {\n                        // Activate the outlet when it has already been instantiated\n                        // Otherwise it will get activated from its `ngOnInit` when instantiated\n                        context.outlet.activateWith(future, cmpFactoryResolver);\n                    }\n                    this.activateChildRoutes(futureNode, null, context.children);\n                }\n            }\n            else {\n                // if we have a componentless route, we recurse but keep the same outlet map.\n                this.activateChildRoutes(futureNode, null, parentContexts);\n            }\n        }\n    };\n    return ActivateRoutes;\n}());\nif (false) {\n    /** @type {?} */\n    ActivateRoutes.prototype.routeReuseStrategy;\n    /** @type {?} */\n    ActivateRoutes.prototype.futureState;\n    /** @type {?} */\n    ActivateRoutes.prototype.currState;\n    /** @type {?} */\n    ActivateRoutes.prototype.forwardEvent;\n}\n/**\n * @param {?} node\n * @return {?}\n */\nfunction advanceActivatedRouteNodeAndItsChildren(node) {\n    advanceActivatedRoute(node.value);\n    node.children.forEach(advanceActivatedRouteNodeAndItsChildren);\n}\n/**\n * @param {?} snapshot\n * @return {?}\n */\nfunction parentLoadedConfig(snapshot) {\n    for (var s = snapshot.parent; s; s = s.parent) {\n        /** @type {?} */\n        var route = s.routeConfig;\n        if (route && route._loadedConfig)\n            return route._loadedConfig;\n        if (route && route.component)\n            return null;\n    }\n    return null;\n}\n/**\n * @param {?} commands\n * @return {?}\n */\nfunction validateCommands(commands) {\n    for (var i = 0; i < commands.length; i++) {\n        /** @type {?} */\n        var cmd = commands[i];\n        if (cmd == null) {\n            throw new Error(\"The requested path contains \" + cmd + \" segment at index \" + i);\n        }\n    }\n}\n//# sourceMappingURL=router.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { LocationStrategy } from '@angular/common';\nimport { Attribute, Directive, ElementRef, HostBinding, HostListener, Input, Renderer2, isDevMode } from '@angular/core';\nimport { NavigationEnd } from '../events';\nimport { Router } from '../router';\nimport { ActivatedRoute } from '../router_state';\n/**\n * \\@description\n *\n * Lets you link to specific routes in your app.\n *\n * Consider the following route configuration:\n * `[{ path: 'user/:name', component: UserCmp }]`.\n * When linking to this `user/:name` route, you use the `RouterLink` directive.\n *\n * If the link is static, you can use the directive as follows:\n * `<a routerLink=\"/user/bob\">link to user component</a>`\n *\n * If you use dynamic values to generate the link, you can pass an array of path\n * segments, followed by the params for each segment.\n *\n * For instance `['/team', teamId, 'user', userName, {details: true}]`\n * means that we want to generate a link to `/team/11/user/bob;details=true`.\n *\n * Multiple static segments can be merged into one\n * (e.g., `['/team/11/user', userName, {details: true}]`).\n *\n * The first segment name can be prepended with `/`, `./`, or `../`:\n * * If the first segment begins with `/`, the router will look up the route from the root of the\n *   app.\n * * If the first segment begins with `./`, or doesn't begin with a slash, the router will\n *   instead look in the children of the current activated route.\n * * And if the first segment begins with `../`, the router will go up one level.\n *\n * You can set query params and fragment as follows:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\n *   link to user component\n * </a>\n * ```\n * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.\n *\n * (Deprecated in v4.0.0 use `queryParamsHandling` instead) You can also tell the\n * directive to preserve the current query params and fragment:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" preserveQueryParams preserveFragment>\n *   link to user component\n * </a>\n * ```\n *\n * You can tell the directive to how to handle queryParams, available options are:\n *  - `'merge'`: merge the queryParams into the current queryParams\n *  - `'preserve'`: preserve the current queryParams\n *  - default/`''`: use the queryParams only\n *\n * Same options for {\\@link NavigationExtras#queryParamsHandling\n * NavigationExtras#queryParamsHandling}.\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" queryParamsHandling=\"merge\">\n *   link to user component\n * </a>\n * ```\n *\n * The router link directive always treats the provided input as a delta to the current url.\n *\n * For instance, if the current url is `/user/(box//aux:team)`.\n *\n * Then the following link `<a [routerLink]=\"['/user/jim']\">Jim</a>` will generate the link\n * `/user/(jim//aux:team)`.\n *\n * See {\\@link Router#createUrlTree createUrlTree} for more information.\n *\n * \\@ngModule RouterModule\n *\n *\n */\nvar RouterLink = /** @class */ (function () {\n    function RouterLink(router, route, tabIndex, renderer, el) {\n        this.router = router;\n        this.route = route;\n        this.commands = [];\n        if (tabIndex == null) {\n            renderer.setAttribute(el.nativeElement, 'tabindex', '0');\n        }\n    }\n    Object.defineProperty(RouterLink.prototype, \"routerLink\", {\n        set: /**\n         * @param {?} commands\n         * @return {?}\n         */\n        function (commands) {\n            if (commands != null) {\n                this.commands = Array.isArray(commands) ? commands : [commands];\n            }\n            else {\n                this.commands = [];\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RouterLink.prototype, \"preserveQueryParams\", {\n        /**\n         * @deprecated 4.0.0 use `queryParamsHandling` instead.\n         */\n        set: /**\n         * @deprecated 4.0.0 use `queryParamsHandling` instead.\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (isDevMode() && /** @type {?} */ (console) && /** @type {?} */ (console.warn)) {\n                console.warn('preserveQueryParams is deprecated!, use queryParamsHandling instead.');\n            }\n            this.preserve = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    RouterLink.prototype.onClick = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var extras = {\n            skipLocationChange: attrBoolValue(this.skipLocationChange),\n            replaceUrl: attrBoolValue(this.replaceUrl),\n        };\n        this.router.navigateByUrl(this.urlTree, extras);\n        return true;\n    };\n    Object.defineProperty(RouterLink.prototype, \"urlTree\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.router.createUrlTree(this.commands, {\n                relativeTo: this.route,\n                queryParams: this.queryParams,\n                fragment: this.fragment,\n                preserveQueryParams: attrBoolValue(this.preserve),\n                queryParamsHandling: this.queryParamsHandling,\n                preserveFragment: attrBoolValue(this.preserveFragment),\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    RouterLink.decorators = [\n        { type: Directive, args: [{ selector: ':not(a)[routerLink]' },] },\n    ];\n    /** @nocollapse */\n    RouterLink.ctorParameters = function () { return [\n        { type: Router },\n        { type: ActivatedRoute },\n        { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] },\n        { type: Renderer2 },\n        { type: ElementRef }\n    ]; };\n    RouterLink.propDecorators = {\n        queryParams: [{ type: Input }],\n        fragment: [{ type: Input }],\n        queryParamsHandling: [{ type: Input }],\n        preserveFragment: [{ type: Input }],\n        skipLocationChange: [{ type: Input }],\n        replaceUrl: [{ type: Input }],\n        routerLink: [{ type: Input }],\n        preserveQueryParams: [{ type: Input }],\n        onClick: [{ type: HostListener, args: ['click',] }]\n    };\n    return RouterLink;\n}());\nexport { RouterLink };\nif (false) {\n    /** @type {?} */\n    RouterLink.prototype.queryParams;\n    /** @type {?} */\n    RouterLink.prototype.fragment;\n    /** @type {?} */\n    RouterLink.prototype.queryParamsHandling;\n    /** @type {?} */\n    RouterLink.prototype.preserveFragment;\n    /** @type {?} */\n    RouterLink.prototype.skipLocationChange;\n    /** @type {?} */\n    RouterLink.prototype.replaceUrl;\n    /** @type {?} */\n    RouterLink.prototype.commands;\n    /** @type {?} */\n    RouterLink.prototype.preserve;\n    /** @type {?} */\n    RouterLink.prototype.router;\n    /** @type {?} */\n    RouterLink.prototype.route;\n}\n/**\n * \\@description\n *\n * Lets you link to specific routes in your app.\n *\n * See `RouterLink` for more information.\n *\n * \\@ngModule RouterModule\n *\n *\n */\nvar RouterLinkWithHref = /** @class */ (function () {\n    function RouterLinkWithHref(router, route, locationStrategy) {\n        var _this = this;\n        this.router = router;\n        this.route = route;\n        this.locationStrategy = locationStrategy;\n        this.commands = [];\n        this.subscription = router.events.subscribe(function (s) {\n            if (s instanceof NavigationEnd) {\n                _this.updateTargetUrlAndHref();\n            }\n        });\n    }\n    Object.defineProperty(RouterLinkWithHref.prototype, \"routerLink\", {\n        set: /**\n         * @param {?} commands\n         * @return {?}\n         */\n        function (commands) {\n            if (commands != null) {\n                this.commands = Array.isArray(commands) ? commands : [commands];\n            }\n            else {\n                this.commands = [];\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RouterLinkWithHref.prototype, \"preserveQueryParams\", {\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (isDevMode() && /** @type {?} */ (console) && /** @type {?} */ (console.warn)) {\n                console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');\n            }\n            this.preserve = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    RouterLinkWithHref.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) { this.updateTargetUrlAndHref(); };\n    /**\n     * @return {?}\n     */\n    RouterLinkWithHref.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () { this.subscription.unsubscribe(); };\n    /**\n     * @param {?} button\n     * @param {?} ctrlKey\n     * @param {?} metaKey\n     * @param {?} shiftKey\n     * @return {?}\n     */\n    RouterLinkWithHref.prototype.onClick = /**\n     * @param {?} button\n     * @param {?} ctrlKey\n     * @param {?} metaKey\n     * @param {?} shiftKey\n     * @return {?}\n     */\n    function (button, ctrlKey, metaKey, shiftKey) {\n        if (button !== 0 || ctrlKey || metaKey || shiftKey) {\n            return true;\n        }\n        if (typeof this.target === 'string' && this.target != '_self') {\n            return true;\n        }\n        /** @type {?} */\n        var extras = {\n            skipLocationChange: attrBoolValue(this.skipLocationChange),\n            replaceUrl: attrBoolValue(this.replaceUrl),\n        };\n        this.router.navigateByUrl(this.urlTree, extras);\n        return false;\n    };\n    /**\n     * @return {?}\n     */\n    RouterLinkWithHref.prototype.updateTargetUrlAndHref = /**\n     * @return {?}\n     */\n    function () {\n        this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));\n    };\n    Object.defineProperty(RouterLinkWithHref.prototype, \"urlTree\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.router.createUrlTree(this.commands, {\n                relativeTo: this.route,\n                queryParams: this.queryParams,\n                fragment: this.fragment,\n                preserveQueryParams: attrBoolValue(this.preserve),\n                queryParamsHandling: this.queryParamsHandling,\n                preserveFragment: attrBoolValue(this.preserveFragment),\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    RouterLinkWithHref.decorators = [\n        { type: Directive, args: [{ selector: 'a[routerLink]' },] },\n    ];\n    /** @nocollapse */\n    RouterLinkWithHref.ctorParameters = function () { return [\n        { type: Router },\n        { type: ActivatedRoute },\n        { type: LocationStrategy }\n    ]; };\n    RouterLinkWithHref.propDecorators = {\n        target: [{ type: HostBinding, args: ['attr.target',] }, { type: Input }],\n        queryParams: [{ type: Input }],\n        fragment: [{ type: Input }],\n        queryParamsHandling: [{ type: Input }],\n        preserveFragment: [{ type: Input }],\n        skipLocationChange: [{ type: Input }],\n        replaceUrl: [{ type: Input }],\n        href: [{ type: HostBinding }],\n        routerLink: [{ type: Input }],\n        preserveQueryParams: [{ type: Input }],\n        onClick: [{ type: HostListener, args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey', '$event.shiftKey'],] }]\n    };\n    return RouterLinkWithHref;\n}());\nexport { RouterLinkWithHref };\nif (false) {\n    /** @type {?} */\n    RouterLinkWithHref.prototype.target;\n    /** @type {?} */\n    RouterLinkWithHref.prototype.queryParams;\n    /** @type {?} */\n    RouterLinkWithHref.prototype.fragment;\n    /** @type {?} */\n    RouterLinkWithHref.prototype.queryParamsHandling;\n    /** @type {?} */\n    RouterLinkWithHref.prototype.preserveFragment;\n    /** @type {?} */\n    RouterLinkWithHref.prototype.skipLocationChange;\n    /** @type {?} */\n    RouterLinkWithHref.prototype.replaceUrl;\n    /** @type {?} */\n    RouterLinkWithHref.prototype.commands;\n    /** @type {?} */\n    RouterLinkWithHref.prototype.subscription;\n    /** @type {?} */\n    RouterLinkWithHref.prototype.preserve;\n    /** @type {?} */\n    RouterLinkWithHref.prototype.href;\n    /** @type {?} */\n    RouterLinkWithHref.prototype.router;\n    /** @type {?} */\n    RouterLinkWithHref.prototype.route;\n    /** @type {?} */\n    RouterLinkWithHref.prototype.locationStrategy;\n}\n/**\n * @param {?} s\n * @return {?}\n */\nfunction attrBoolValue(s) {\n    return s === '' || !!s;\n}\n//# sourceMappingURL=router_link.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ChangeDetectorRef, ContentChildren, Directive, ElementRef, Input, QueryList, Renderer2 } from '@angular/core';\nimport { NavigationEnd } from '../events';\nimport { Router } from '../router';\nimport { RouterLink, RouterLinkWithHref } from './router_link';\n/**\n *\n * \\@description\n *\n * Lets you add a CSS class to an element when the link's route becomes active.\n *\n * This directive lets you add a CSS class to an element when the link's route\n * becomes active.\n *\n * Consider the following example:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n *\n * When the url is either '/user' or '/user/bob', the active-link class will\n * be added to the `a` tag. If the url changes, the class will be removed.\n *\n * You can set more than one class, as follows:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n * ```\n *\n * You can configure RouterLinkActive by passing `exact: true`. This will add the classes\n * only when the url matches the link exactly.\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n * true}\">Bob</a>\n * ```\n *\n * You can assign the RouterLinkActive instance to a template variable and directly check\n * the `isActive` status.\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n *   Bob {{ rla.isActive ? '(already open)' : ''}}\n * </a>\n * ```\n *\n * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.\n *\n * ```\n * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n *   <a routerLink=\"/user/jim\">Jim</a>\n *   <a routerLink=\"/user/bob\">Bob</a>\n * </div>\n * ```\n *\n * This will set the active-link class on the div tag if the url is either '/user/jim' or\n * '/user/bob'.\n *\n * \\@ngModule RouterModule\n *\n *\n */\nvar RouterLinkActive = /** @class */ (function () {\n    function RouterLinkActive(router, element, renderer, cdr) {\n        var _this = this;\n        this.router = router;\n        this.element = element;\n        this.renderer = renderer;\n        this.cdr = cdr;\n        this.classes = [];\n        this.isActive = false;\n        this.routerLinkActiveOptions = { exact: false };\n        this.subscription = router.events.subscribe(function (s) {\n            if (s instanceof NavigationEnd) {\n                _this.update();\n            }\n        });\n    }\n    /**\n     * @return {?}\n     */\n    RouterLinkActive.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this.links.changes.subscribe(function (_) { return _this.update(); });\n        this.linksWithHrefs.changes.subscribe(function (_) { return _this.update(); });\n        this.update();\n    };\n    Object.defineProperty(RouterLinkActive.prototype, \"routerLinkActive\", {\n        set: /**\n         * @param {?} data\n         * @return {?}\n         */\n        function (data) {\n            /** @type {?} */\n            var classes = Array.isArray(data) ? data : data.split(' ');\n            this.classes = classes.filter(function (c) { return !!c; });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    RouterLinkActive.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) { this.update(); };\n    /**\n     * @return {?}\n     */\n    RouterLinkActive.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () { this.subscription.unsubscribe(); };\n    /**\n     * @return {?}\n     */\n    RouterLinkActive.prototype.update = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this.links || !this.linksWithHrefs || !this.router.navigated)\n            return;\n        Promise.resolve().then(function () {\n            /** @type {?} */\n            var hasActiveLinks = _this.hasActiveLinks();\n            if (_this.isActive !== hasActiveLinks) {\n                (/** @type {?} */ (_this)).isActive = hasActiveLinks;\n                _this.classes.forEach(function (c) {\n                    if (hasActiveLinks) {\n                        _this.renderer.addClass(_this.element.nativeElement, c);\n                    }\n                    else {\n                        _this.renderer.removeClass(_this.element.nativeElement, c);\n                    }\n                });\n            }\n        });\n    };\n    /**\n     * @param {?} router\n     * @return {?}\n     */\n    RouterLinkActive.prototype.isLinkActive = /**\n     * @param {?} router\n     * @return {?}\n     */\n    function (router) {\n        var _this = this;\n        return function (link) {\n            return router.isActive(link.urlTree, _this.routerLinkActiveOptions.exact);\n        };\n    };\n    /**\n     * @return {?}\n     */\n    RouterLinkActive.prototype.hasActiveLinks = /**\n     * @return {?}\n     */\n    function () {\n        return this.links.some(this.isLinkActive(this.router)) ||\n            this.linksWithHrefs.some(this.isLinkActive(this.router));\n    };\n    RouterLinkActive.decorators = [\n        { type: Directive, args: [{\n                    selector: '[routerLinkActive]',\n                    exportAs: 'routerLinkActive',\n                },] },\n    ];\n    /** @nocollapse */\n    RouterLinkActive.ctorParameters = function () { return [\n        { type: Router },\n        { type: ElementRef },\n        { type: Renderer2 },\n        { type: ChangeDetectorRef }\n    ]; };\n    RouterLinkActive.propDecorators = {\n        links: [{ type: ContentChildren, args: [RouterLink, { descendants: true },] }],\n        linksWithHrefs: [{ type: ContentChildren, args: [RouterLinkWithHref, { descendants: true },] }],\n        routerLinkActiveOptions: [{ type: Input }],\n        routerLinkActive: [{ type: Input }]\n    };\n    return RouterLinkActive;\n}());\nexport { RouterLinkActive };\nif (false) {\n    /** @type {?} */\n    RouterLinkActive.prototype.links;\n    /** @type {?} */\n    RouterLinkActive.prototype.linksWithHrefs;\n    /** @type {?} */\n    RouterLinkActive.prototype.classes;\n    /** @type {?} */\n    RouterLinkActive.prototype.subscription;\n    /** @type {?} */\n    RouterLinkActive.prototype.isActive;\n    /** @type {?} */\n    RouterLinkActive.prototype.routerLinkActiveOptions;\n    /** @type {?} */\n    RouterLinkActive.prototype.router;\n    /** @type {?} */\n    RouterLinkActive.prototype.element;\n    /** @type {?} */\n    RouterLinkActive.prototype.renderer;\n    /** @type {?} */\n    RouterLinkActive.prototype.cdr;\n}\n//# sourceMappingURL=router_link_active.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Store contextual information about a `RouterOutlet`\n *\n *\n */\nvar /**\n * Store contextual information about a `RouterOutlet`\n *\n *\n */\nOutletContext = /** @class */ (function () {\n    function OutletContext() {\n        this.outlet = null;\n        this.route = null;\n        this.resolver = null;\n        this.children = new ChildrenOutletContexts();\n        this.attachRef = null;\n    }\n    return OutletContext;\n}());\n/**\n * Store contextual information about a `RouterOutlet`\n *\n *\n */\nexport { OutletContext };\nif (false) {\n    /** @type {?} */\n    OutletContext.prototype.outlet;\n    /** @type {?} */\n    OutletContext.prototype.route;\n    /** @type {?} */\n    OutletContext.prototype.resolver;\n    /** @type {?} */\n    OutletContext.prototype.children;\n    /** @type {?} */\n    OutletContext.prototype.attachRef;\n}\n/**\n * Store contextual information about the children (= nested) `RouterOutlet`\n *\n *\n */\nvar /**\n * Store contextual information about the children (= nested) `RouterOutlet`\n *\n *\n */\nChildrenOutletContexts = /** @class */ (function () {\n    function ChildrenOutletContexts() {\n        this.contexts = new Map();\n    }\n    /** Called when a `RouterOutlet` directive is instantiated */\n    /**\n     * Called when a `RouterOutlet` directive is instantiated\n     * @param {?} childName\n     * @param {?} outlet\n     * @return {?}\n     */\n    ChildrenOutletContexts.prototype.onChildOutletCreated = /**\n     * Called when a `RouterOutlet` directive is instantiated\n     * @param {?} childName\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (childName, outlet) {\n        /** @type {?} */\n        var context = this.getOrCreateContext(childName);\n        context.outlet = outlet;\n        this.contexts.set(childName, context);\n    };\n    /**\n     * Called when a `RouterOutlet` directive is destroyed.\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n     * re-created later.\n     */\n    /**\n     * Called when a `RouterOutlet` directive is destroyed.\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n     * re-created later.\n     * @param {?} childName\n     * @return {?}\n     */\n    ChildrenOutletContexts.prototype.onChildOutletDestroyed = /**\n     * Called when a `RouterOutlet` directive is destroyed.\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n     * re-created later.\n     * @param {?} childName\n     * @return {?}\n     */\n    function (childName) {\n        /** @type {?} */\n        var context = this.getContext(childName);\n        if (context) {\n            context.outlet = null;\n        }\n    };\n    /**\n     * Called when the corresponding route is deactivated during navigation.\n     * Because the component get destroyed, all children outlet are destroyed.\n     */\n    /**\n     * Called when the corresponding route is deactivated during navigation.\n     * Because the component get destroyed, all children outlet are destroyed.\n     * @return {?}\n     */\n    ChildrenOutletContexts.prototype.onOutletDeactivated = /**\n     * Called when the corresponding route is deactivated during navigation.\n     * Because the component get destroyed, all children outlet are destroyed.\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var contexts = this.contexts;\n        this.contexts = new Map();\n        return contexts;\n    };\n    /**\n     * @param {?} contexts\n     * @return {?}\n     */\n    ChildrenOutletContexts.prototype.onOutletReAttached = /**\n     * @param {?} contexts\n     * @return {?}\n     */\n    function (contexts) { this.contexts = contexts; };\n    /**\n     * @param {?} childName\n     * @return {?}\n     */\n    ChildrenOutletContexts.prototype.getOrCreateContext = /**\n     * @param {?} childName\n     * @return {?}\n     */\n    function (childName) {\n        /** @type {?} */\n        var context = this.getContext(childName);\n        if (!context) {\n            context = new OutletContext();\n            this.contexts.set(childName, context);\n        }\n        return context;\n    };\n    /**\n     * @param {?} childName\n     * @return {?}\n     */\n    ChildrenOutletContexts.prototype.getContext = /**\n     * @param {?} childName\n     * @return {?}\n     */\n    function (childName) { return this.contexts.get(childName) || null; };\n    return ChildrenOutletContexts;\n}());\n/**\n * Store contextual information about the children (= nested) `RouterOutlet`\n *\n *\n */\nexport { ChildrenOutletContexts };\nif (false) {\n    /** @type {?} */\n    ChildrenOutletContexts.prototype.contexts;\n}\n//# sourceMappingURL=router_outlet_context.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Attribute, ChangeDetectorRef, ComponentFactoryResolver, Directive, EventEmitter, Output, ViewContainerRef } from '@angular/core';\nimport { ChildrenOutletContexts } from '../router_outlet_context';\nimport { ActivatedRoute } from '../router_state';\nimport { PRIMARY_OUTLET } from '../shared';\n/**\n * \\@description\n *\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * ```\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n *\n * A router outlet will emit an activate event any time a new component is being instantiated,\n * and a deactivate event when it is being destroyed.\n *\n * ```\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'></router-outlet>\n * ```\n * \\@ngModule RouterModule\n *\n *\n */\nvar RouterOutlet = /** @class */ (function () {\n    function RouterOutlet(parentContexts, location, resolver, name, changeDetector) {\n        this.parentContexts = parentContexts;\n        this.location = location;\n        this.resolver = resolver;\n        this.changeDetector = changeDetector;\n        this.activated = null;\n        this._activatedRoute = null;\n        this.activateEvents = new EventEmitter();\n        this.deactivateEvents = new EventEmitter();\n        this.name = name || PRIMARY_OUTLET;\n        parentContexts.onChildOutletCreated(this.name, this);\n    }\n    /**\n     * @return {?}\n     */\n    RouterOutlet.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () { this.parentContexts.onChildOutletDestroyed(this.name); };\n    /**\n     * @return {?}\n     */\n    RouterOutlet.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        if (!this.activated) {\n            /** @type {?} */\n            var context = this.parentContexts.getContext(this.name);\n            if (context && context.route) {\n                if (context.attachRef) {\n                    // `attachRef` is populated when there is an existing component to mount\n                    this.attach(context.attachRef, context.route);\n                }\n                else {\n                    // otherwise the component defined in the configuration is created\n                    this.activateWith(context.route, context.resolver || null);\n                }\n            }\n        }\n    };\n    Object.defineProperty(RouterOutlet.prototype, \"isActivated\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return !!this.activated; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RouterOutlet.prototype, \"component\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this.activated)\n                throw new Error('Outlet is not activated');\n            return this.activated.instance;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RouterOutlet.prototype, \"activatedRoute\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this.activated)\n                throw new Error('Outlet is not activated');\n            return /** @type {?} */ (this._activatedRoute);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RouterOutlet.prototype, \"activatedRouteData\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (this._activatedRoute) {\n                return this._activatedRoute.snapshot.data;\n            }\n            return {};\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     */\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     * @return {?}\n     */\n    RouterOutlet.prototype.detach = /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     * @return {?}\n     */\n    function () {\n        if (!this.activated)\n            throw new Error('Outlet is not activated');\n        this.location.detach();\n        /** @type {?} */\n        var cmp = this.activated;\n        this.activated = null;\n        this._activatedRoute = null;\n        return cmp;\n    };\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     */\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     * @param {?} ref\n     * @param {?} activatedRoute\n     * @return {?}\n     */\n    RouterOutlet.prototype.attach = /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     * @param {?} ref\n     * @param {?} activatedRoute\n     * @return {?}\n     */\n    function (ref, activatedRoute) {\n        this.activated = ref;\n        this._activatedRoute = activatedRoute;\n        this.location.insert(ref.hostView);\n    };\n    /**\n     * @return {?}\n     */\n    RouterOutlet.prototype.deactivate = /**\n     * @return {?}\n     */\n    function () {\n        if (this.activated) {\n            /** @type {?} */\n            var c = this.component;\n            this.activated.destroy();\n            this.activated = null;\n            this._activatedRoute = null;\n            this.deactivateEvents.emit(c);\n        }\n    };\n    /**\n     * @param {?} activatedRoute\n     * @param {?} resolver\n     * @return {?}\n     */\n    RouterOutlet.prototype.activateWith = /**\n     * @param {?} activatedRoute\n     * @param {?} resolver\n     * @return {?}\n     */\n    function (activatedRoute, resolver) {\n        if (this.isActivated) {\n            throw new Error('Cannot activate an already activated outlet');\n        }\n        this._activatedRoute = activatedRoute;\n        /** @type {?} */\n        var snapshot = activatedRoute._futureSnapshot;\n        /** @type {?} */\n        var component = /** @type {?} */ (/** @type {?} */ ((snapshot.routeConfig)).component);\n        resolver = resolver || this.resolver;\n        /** @type {?} */\n        var factory = resolver.resolveComponentFactory(component);\n        /** @type {?} */\n        var childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n        /** @type {?} */\n        var injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);\n        this.activated = this.location.createComponent(factory, this.location.length, injector);\n        // Calling `markForCheck` to make sure we will run the change detection when the\n        // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n        this.changeDetector.markForCheck();\n        this.activateEvents.emit(this.activated.instance);\n    };\n    RouterOutlet.decorators = [\n        { type: Directive, args: [{ selector: 'router-outlet', exportAs: 'outlet' },] },\n    ];\n    /** @nocollapse */\n    RouterOutlet.ctorParameters = function () { return [\n        { type: ChildrenOutletContexts },\n        { type: ViewContainerRef },\n        { type: ComponentFactoryResolver },\n        { type: String, decorators: [{ type: Attribute, args: ['name',] }] },\n        { type: ChangeDetectorRef }\n    ]; };\n    RouterOutlet.propDecorators = {\n        activateEvents: [{ type: Output, args: ['activate',] }],\n        deactivateEvents: [{ type: Output, args: ['deactivate',] }]\n    };\n    return RouterOutlet;\n}());\nexport { RouterOutlet };\nif (false) {\n    /** @type {?} */\n    RouterOutlet.prototype.activated;\n    /** @type {?} */\n    RouterOutlet.prototype._activatedRoute;\n    /** @type {?} */\n    RouterOutlet.prototype.name;\n    /** @type {?} */\n    RouterOutlet.prototype.activateEvents;\n    /** @type {?} */\n    RouterOutlet.prototype.deactivateEvents;\n    /** @type {?} */\n    RouterOutlet.prototype.parentContexts;\n    /** @type {?} */\n    RouterOutlet.prototype.location;\n    /** @type {?} */\n    RouterOutlet.prototype.resolver;\n    /** @type {?} */\n    RouterOutlet.prototype.changeDetector;\n}\nvar OutletInjector = /** @class */ (function () {\n    function OutletInjector(route, childContexts, parent) {\n        this.route = route;\n        this.childContexts = childContexts;\n        this.parent = parent;\n    }\n    /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    OutletInjector.prototype.get = /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    function (token, notFoundValue) {\n        if (token === ActivatedRoute) {\n            return this.route;\n        }\n        if (token === ChildrenOutletContexts) {\n            return this.childContexts;\n        }\n        return this.parent.get(token, notFoundValue);\n    };\n    return OutletInjector;\n}());\nif (false) {\n    /** @type {?} */\n    OutletInjector.prototype.route;\n    /** @type {?} */\n    OutletInjector.prototype.childContexts;\n    /** @type {?} */\n    OutletInjector.prototype.parent;\n}\n//# sourceMappingURL=router_outlet.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n*@license\n*Copyright Google Inc. All Rights Reserved.\n*\n*Use of this source code is governed by an MIT-style license that can be\n*found in the LICENSE file at https://angular.io/license\n*/\nimport { Compiler, Injectable, Injector, NgModuleFactoryLoader, NgModuleRef } from '@angular/core';\nimport { from, of } from 'rxjs';\nimport { catchError, concatMap, filter, map, mergeAll, mergeMap } from 'rxjs/operators';\nimport { NavigationEnd, RouteConfigLoadEnd, RouteConfigLoadStart } from './events';\nimport { Router } from './router';\nimport { RouterConfigLoader } from './router_config_loader';\n/**\n * \\@description\n *\n * Provides a preloading strategy.\n *\n * \\@experimental\n * @abstract\n */\nvar /**\n * \\@description\n *\n * Provides a preloading strategy.\n *\n * \\@experimental\n * @abstract\n */\nPreloadingStrategy = /** @class */ (function () {\n    function PreloadingStrategy() {\n    }\n    return PreloadingStrategy;\n}());\n/**\n * \\@description\n *\n * Provides a preloading strategy.\n *\n * \\@experimental\n * @abstract\n */\nexport { PreloadingStrategy };\nif (false) {\n    /**\n     * @abstract\n     * @param {?} route\n     * @param {?} fn\n     * @return {?}\n     */\n    PreloadingStrategy.prototype.preload = function (route, fn) { };\n}\n/**\n * \\@description\n *\n * Provides a preloading strategy that preloads all modules as quickly as possible.\n *\n * ```\n * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n * ```\n *\n * \\@experimental\n */\nvar /**\n * \\@description\n *\n * Provides a preloading strategy that preloads all modules as quickly as possible.\n *\n * ```\n * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n * ```\n *\n * \\@experimental\n */\nPreloadAllModules = /** @class */ (function () {\n    function PreloadAllModules() {\n    }\n    /**\n     * @param {?} route\n     * @param {?} fn\n     * @return {?}\n     */\n    PreloadAllModules.prototype.preload = /**\n     * @param {?} route\n     * @param {?} fn\n     * @return {?}\n     */\n    function (route, fn) {\n        return fn().pipe(catchError(function () { return of(null); }));\n    };\n    return PreloadAllModules;\n}());\n/**\n * \\@description\n *\n * Provides a preloading strategy that preloads all modules as quickly as possible.\n *\n * ```\n * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n * ```\n *\n * \\@experimental\n */\nexport { PreloadAllModules };\n/**\n * \\@description\n *\n * Provides a preloading strategy that does not preload any modules.\n *\n * This strategy is enabled by default.\n *\n * \\@experimental\n */\nvar /**\n * \\@description\n *\n * Provides a preloading strategy that does not preload any modules.\n *\n * This strategy is enabled by default.\n *\n * \\@experimental\n */\nNoPreloading = /** @class */ (function () {\n    function NoPreloading() {\n    }\n    /**\n     * @param {?} route\n     * @param {?} fn\n     * @return {?}\n     */\n    NoPreloading.prototype.preload = /**\n     * @param {?} route\n     * @param {?} fn\n     * @return {?}\n     */\n    function (route, fn) { return of(null); };\n    return NoPreloading;\n}());\n/**\n * \\@description\n *\n * Provides a preloading strategy that does not preload any modules.\n *\n * This strategy is enabled by default.\n *\n * \\@experimental\n */\nexport { NoPreloading };\n/**\n * The preloader optimistically loads all router configurations to\n * make navigations into lazily-loaded sections of the application faster.\n *\n * The preloader runs in the background. When the router bootstraps, the preloader\n * starts listening to all navigation events. After every such event, the preloader\n * will check if any configurations can be loaded lazily.\n *\n * If a route is protected by `canLoad` guards, the preloaded will not load it.\n *\n *\n */\nvar RouterPreloader = /** @class */ (function () {\n    function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {\n        this.router = router;\n        this.injector = injector;\n        this.preloadingStrategy = preloadingStrategy;\n        /** @type {?} */\n        var onStartLoad = function (r) { return router.triggerEvent(new RouteConfigLoadStart(r)); };\n        /** @type {?} */\n        var onEndLoad = function (r) { return router.triggerEvent(new RouteConfigLoadEnd(r)); };\n        this.loader = new RouterConfigLoader(moduleLoader, compiler, onStartLoad, onEndLoad);\n    }\n    /**\n     * @return {?}\n     */\n    RouterPreloader.prototype.setUpPreloading = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this.subscription =\n            this.router.events\n                .pipe(filter(function (e) { return e instanceof NavigationEnd; }), concatMap(function () { return _this.preload(); }))\n                .subscribe(function () { });\n    };\n    /**\n     * @return {?}\n     */\n    RouterPreloader.prototype.preload = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var ngModule = this.injector.get(NgModuleRef);\n        return this.processRoutes(ngModule, this.router.config);\n    };\n    // TODO(jasonaden): This class relies on code external to the class to call setUpPreloading. If\n    // this hasn't been done, ngOnDestroy will fail as this.subscription will be undefined. This\n    // should be refactored.\n    /**\n     * @return {?}\n     */\n    RouterPreloader.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () { this.subscription.unsubscribe(); };\n    /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @return {?}\n     */\n    RouterPreloader.prototype.processRoutes = /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @return {?}\n     */\n    function (ngModule, routes) {\n        /** @type {?} */\n        var res = [];\n        for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n            var route = routes_1[_i];\n            // we already have the config loaded, just recurse\n            if (route.loadChildren && !route.canLoad && route._loadedConfig) {\n                /** @type {?} */\n                var childConfig = route._loadedConfig;\n                res.push(this.processRoutes(childConfig.module, childConfig.routes));\n                // no config loaded, fetch the config\n            }\n            else if (route.loadChildren && !route.canLoad) {\n                res.push(this.preloadConfig(ngModule, route));\n                // recurse into children\n            }\n            else if (route.children) {\n                res.push(this.processRoutes(ngModule, route.children));\n            }\n        }\n        return from(res).pipe(mergeAll(), map(function (_) { return void 0; }));\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} route\n     * @return {?}\n     */\n    RouterPreloader.prototype.preloadConfig = /**\n     * @param {?} ngModule\n     * @param {?} route\n     * @return {?}\n     */\n    function (ngModule, route) {\n        var _this = this;\n        return this.preloadingStrategy.preload(route, function () {\n            /** @type {?} */\n            var loaded$ = _this.loader.load(ngModule.injector, route);\n            return loaded$.pipe(mergeMap(function (config) {\n                route._loadedConfig = config;\n                return _this.processRoutes(config.module, config.routes);\n            }));\n        });\n    };\n    RouterPreloader.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    RouterPreloader.ctorParameters = function () { return [\n        { type: Router },\n        { type: NgModuleFactoryLoader },\n        { type: Compiler },\n        { type: Injector },\n        { type: PreloadingStrategy }\n    ]; };\n    return RouterPreloader;\n}());\nexport { RouterPreloader };\nif (false) {\n    /** @type {?} */\n    RouterPreloader.prototype.loader;\n    /** @type {?} */\n    RouterPreloader.prototype.subscription;\n    /** @type {?} */\n    RouterPreloader.prototype.router;\n    /** @type {?} */\n    RouterPreloader.prototype.injector;\n    /** @type {?} */\n    RouterPreloader.prototype.preloadingStrategy;\n}\n//# sourceMappingURL=router_preloader.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { NavigationEnd, NavigationStart, Scroll } from './events';\nvar RouterScroller = /** @class */ (function () {\n    function RouterScroller(router, viewportScroller, options) {\n        if (options === void 0) { options = {}; }\n        this.router = router;\n        this.viewportScroller = viewportScroller;\n        this.options = options;\n        this.lastId = 0;\n        this.lastSource = 'imperative';\n        this.restoredId = 0;\n        this.store = {};\n        // Default both options to 'disabled'\n        options.scrollPositionRestoration = options.scrollPositionRestoration || 'disabled';\n        options.anchorScrolling = options.anchorScrolling || 'disabled';\n    }\n    /**\n     * @return {?}\n     */\n    RouterScroller.prototype.init = /**\n     * @return {?}\n     */\n    function () {\n        // we want to disable the automatic scrolling because having two places\n        // responsible for scrolling results race conditions, especially given\n        // that browser don't implement this behavior consistently\n        if (this.options.scrollPositionRestoration !== 'disabled') {\n            this.viewportScroller.setHistoryScrollRestoration('manual');\n        }\n        this.routerEventsSubscription = this.createScrollEvents();\n        this.scrollEventsSubscription = this.consumeScrollEvents();\n    };\n    /**\n     * @return {?}\n     */\n    RouterScroller.prototype.createScrollEvents = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        return this.router.events.subscribe(function (e) {\n            if (e instanceof NavigationStart) {\n                // store the scroll position of the current stable navigations.\n                // store the scroll position of the current stable navigations.\n                _this.store[_this.lastId] = _this.viewportScroller.getScrollPosition();\n                _this.lastSource = e.navigationTrigger;\n                _this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;\n            }\n            else if (e instanceof NavigationEnd) {\n                _this.lastId = e.id;\n                _this.scheduleScrollEvent(e, _this.router.parseUrl(e.urlAfterRedirects).fragment);\n            }\n        });\n    };\n    /**\n     * @return {?}\n     */\n    RouterScroller.prototype.consumeScrollEvents = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        return this.router.events.subscribe(function (e) {\n            if (!(e instanceof Scroll))\n                return;\n            // a popstate event. The pop state event will always ignore anchor scrolling.\n            if (e.position) {\n                if (_this.options.scrollPositionRestoration === 'top') {\n                    _this.viewportScroller.scrollToPosition([0, 0]);\n                }\n                else if (_this.options.scrollPositionRestoration === 'enabled') {\n                    _this.viewportScroller.scrollToPosition(e.position);\n                }\n                // imperative navigation \"forward\"\n            }\n            else {\n                if (e.anchor && _this.options.anchorScrolling === 'enabled') {\n                    _this.viewportScroller.scrollToAnchor(e.anchor);\n                }\n                else if (_this.options.scrollPositionRestoration !== 'disabled') {\n                    _this.viewportScroller.scrollToPosition([0, 0]);\n                }\n            }\n        });\n    };\n    /**\n     * @param {?} routerEvent\n     * @param {?} anchor\n     * @return {?}\n     */\n    RouterScroller.prototype.scheduleScrollEvent = /**\n     * @param {?} routerEvent\n     * @param {?} anchor\n     * @return {?}\n     */\n    function (routerEvent, anchor) {\n        this.router.triggerEvent(new Scroll(routerEvent, this.lastSource === 'popstate' ? this.store[this.restoredId] : null, anchor));\n    };\n    /**\n     * @return {?}\n     */\n    RouterScroller.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this.routerEventsSubscription) {\n            this.routerEventsSubscription.unsubscribe();\n        }\n        if (this.scrollEventsSubscription) {\n            this.scrollEventsSubscription.unsubscribe();\n        }\n    };\n    return RouterScroller;\n}());\nexport { RouterScroller };\nif (false) {\n    /** @type {?} */\n    RouterScroller.prototype.routerEventsSubscription;\n    /** @type {?} */\n    RouterScroller.prototype.scrollEventsSubscription;\n    /** @type {?} */\n    RouterScroller.prototype.lastId;\n    /** @type {?} */\n    RouterScroller.prototype.lastSource;\n    /** @type {?} */\n    RouterScroller.prototype.restoredId;\n    /** @type {?} */\n    RouterScroller.prototype.store;\n    /** @type {?} */\n    RouterScroller.prototype.router;\n    /**\n     * \\@docsNotRequired\n     * @type {?}\n     */\n    RouterScroller.prototype.viewportScroller;\n    /** @type {?} */\n    RouterScroller.prototype.options;\n}\n//# sourceMappingURL=router_scroller.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { APP_BASE_HREF, HashLocationStrategy, LOCATION_INITIALIZED, Location, LocationStrategy, PathLocationStrategy, PlatformLocation, ViewportScroller } from '@angular/common';\nimport { ANALYZE_FOR_ENTRY_COMPONENTS, APP_BOOTSTRAP_LISTENER, APP_INITIALIZER, ApplicationRef, Compiler, Inject, Injectable, InjectionToken, Injector, NgModule, NgModuleFactoryLoader, NgProbeToken, Optional, SkipSelf, SystemJsNgModuleLoader } from '@angular/core';\nimport { ɵgetDOM as getDOM } from '@angular/platform-browser';\nimport { Subject, of } from 'rxjs';\nimport { EmptyOutletComponent } from './components/empty_outlet';\nimport { RouterLink, RouterLinkWithHref } from './directives/router_link';\nimport { RouterLinkActive } from './directives/router_link_active';\nimport { RouterOutlet } from './directives/router_outlet';\nimport { RouteReuseStrategy } from './route_reuse_strategy';\nimport { Router } from './router';\nimport { ROUTES } from './router_config_loader';\nimport { ChildrenOutletContexts } from './router_outlet_context';\nimport { NoPreloading, PreloadAllModules, PreloadingStrategy, RouterPreloader } from './router_preloader';\nimport { RouterScroller } from './router_scroller';\nimport { ActivatedRoute } from './router_state';\nimport { UrlHandlingStrategy } from './url_handling_strategy';\nimport { DefaultUrlSerializer, UrlSerializer } from './url_tree';\nimport { flatten } from './utils/collection';\n/** *\n * \\@description\n *\n * Contains a list of directives\n *\n *\n  @type {?} */\nvar ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, EmptyOutletComponent];\n/** *\n * \\@description\n *\n * Is used in DI to configure the router.\n *\n *\n  @type {?} */\nexport var ROUTER_CONFIGURATION = new InjectionToken('ROUTER_CONFIGURATION');\n/** *\n * \\@docsNotRequired\n  @type {?} */\nexport var ROUTER_FORROOT_GUARD = new InjectionToken('ROUTER_FORROOT_GUARD');\n/** @type {?} */\nexport var ROUTER_PROVIDERS = [\n    Location,\n    { provide: UrlSerializer, useClass: DefaultUrlSerializer },\n    {\n        provide: Router,\n        useFactory: setupRouter,\n        deps: [\n            ApplicationRef, UrlSerializer, ChildrenOutletContexts, Location, Injector,\n            NgModuleFactoryLoader, Compiler, ROUTES, ROUTER_CONFIGURATION,\n            [UrlHandlingStrategy, new Optional()], [RouteReuseStrategy, new Optional()]\n        ]\n    },\n    ChildrenOutletContexts,\n    { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },\n    { provide: NgModuleFactoryLoader, useClass: SystemJsNgModuleLoader },\n    RouterPreloader,\n    NoPreloading,\n    PreloadAllModules,\n    { provide: ROUTER_CONFIGURATION, useValue: { enableTracing: false } },\n];\n/**\n * @return {?}\n */\nexport function routerNgProbeToken() {\n    return new NgProbeToken('Router', Router);\n}\n/**\n * \\@usageNotes\n *\n * RouterModule can be imported multiple times: once per lazily-loaded bundle.\n * Since the router deals with a global shared resource--location, we cannot have\n * more than one router service active.\n *\n * That is why there are two ways to create the module: `RouterModule.forRoot` and\n * `RouterModule.forChild`.\n *\n * * `forRoot` creates a module that contains all the directives, the given routes, and the router\n *   service itself.\n * * `forChild` creates a module that contains all the directives and the given routes, but does not\n *   include the router service.\n *\n * When registered at the root, the module should be used as follows\n *\n * ```\n * \\@NgModule({\n *   imports: [RouterModule.forRoot(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * For submodules and lazy loaded submodules the module should be used as follows:\n *\n * ```\n * \\@NgModule({\n *   imports: [RouterModule.forChild(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * \\@description\n *\n * Adds router directives and providers.\n *\n * Managing state transitions is one of the hardest parts of building applications. This is\n * especially true on the web, where you also need to ensure that the state is reflected in the URL.\n * In addition, we often want to split applications into multiple bundles and load them on demand.\n * Doing this transparently is not trivial.\n *\n * The Angular router solves these problems. Using the router, you can declaratively specify\n * application states, manage state transitions while taking care of the URL, and load bundles on\n * demand.\n *\n * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an\n * overview of how the router should be used.\n *\n *\n */\nvar RouterModule = /** @class */ (function () {\n    // Note: We are injecting the Router so it gets created eagerly...\n    function RouterModule(guard, router) {\n    }\n    /**\n     * Creates a module with all the router providers and directives. It also optionally sets up an\n     * application listener to perform an initial navigation.\n     *\n     * Options (see `ExtraOptions`):\n     * * `enableTracing` makes the router log all its internal events to the console.\n     * * `useHash` enables the location strategy that uses the URL fragment instead of the history\n     * API.\n     * * `initialNavigation` disables the initial navigation.\n     * * `errorHandler` provides a custom error handler.\n     * * `preloadingStrategy` configures a preloading strategy (see `PreloadAllModules`).\n     * * `onSameUrlNavigation` configures how the router handles navigation to the current URL. See\n     * `ExtraOptions` for more details.\n     * * `paramsInheritanceStrategy` defines how the router merges params, data and resolved data\n     * from parent to child routes.\n     */\n    /**\n     * Creates a module with all the router providers and directives. It also optionally sets up an\n     * application listener to perform an initial navigation.\n     *\n     * Options (see `ExtraOptions`):\n     * * `enableTracing` makes the router log all its internal events to the console.\n     * * `useHash` enables the location strategy that uses the URL fragment instead of the history\n     * API.\n     * * `initialNavigation` disables the initial navigation.\n     * * `errorHandler` provides a custom error handler.\n     * * `preloadingStrategy` configures a preloading strategy (see `PreloadAllModules`).\n     * * `onSameUrlNavigation` configures how the router handles navigation to the current URL. See\n     * `ExtraOptions` for more details.\n     * * `paramsInheritanceStrategy` defines how the router merges params, data and resolved data\n     * from parent to child routes.\n     * @param {?} routes\n     * @param {?=} config\n     * @return {?}\n     */\n    RouterModule.forRoot = /**\n     * Creates a module with all the router providers and directives. It also optionally sets up an\n     * application listener to perform an initial navigation.\n     *\n     * Options (see `ExtraOptions`):\n     * * `enableTracing` makes the router log all its internal events to the console.\n     * * `useHash` enables the location strategy that uses the URL fragment instead of the history\n     * API.\n     * * `initialNavigation` disables the initial navigation.\n     * * `errorHandler` provides a custom error handler.\n     * * `preloadingStrategy` configures a preloading strategy (see `PreloadAllModules`).\n     * * `onSameUrlNavigation` configures how the router handles navigation to the current URL. See\n     * `ExtraOptions` for more details.\n     * * `paramsInheritanceStrategy` defines how the router merges params, data and resolved data\n     * from parent to child routes.\n     * @param {?} routes\n     * @param {?=} config\n     * @return {?}\n     */\n    function (routes, config) {\n        return {\n            ngModule: RouterModule,\n            providers: [\n                ROUTER_PROVIDERS,\n                provideRoutes(routes),\n                {\n                    provide: ROUTER_FORROOT_GUARD,\n                    useFactory: provideForRootGuard,\n                    deps: [[Router, new Optional(), new SkipSelf()]]\n                },\n                { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} },\n                {\n                    provide: LocationStrategy,\n                    useFactory: provideLocationStrategy,\n                    deps: [\n                        PlatformLocation, [new Inject(APP_BASE_HREF), new Optional()], ROUTER_CONFIGURATION\n                    ]\n                },\n                {\n                    provide: RouterScroller,\n                    useFactory: createRouterScroller,\n                    deps: [Router, ViewportScroller, ROUTER_CONFIGURATION]\n                },\n                {\n                    provide: PreloadingStrategy,\n                    useExisting: config && config.preloadingStrategy ? config.preloadingStrategy :\n                        NoPreloading\n                },\n                { provide: NgProbeToken, multi: true, useFactory: routerNgProbeToken },\n                provideRouterInitializer(),\n            ],\n        };\n    };\n    /**\n     * Creates a module with all the router directives and a provider registering routes.\n     */\n    /**\n     * Creates a module with all the router directives and a provider registering routes.\n     * @param {?} routes\n     * @return {?}\n     */\n    RouterModule.forChild = /**\n     * Creates a module with all the router directives and a provider registering routes.\n     * @param {?} routes\n     * @return {?}\n     */\n    function (routes) {\n        return { ngModule: RouterModule, providers: [provideRoutes(routes)] };\n    };\n    RouterModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: ROUTER_DIRECTIVES,\n                    exports: ROUTER_DIRECTIVES,\n                    entryComponents: [EmptyOutletComponent]\n                },] },\n    ];\n    /** @nocollapse */\n    RouterModule.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [ROUTER_FORROOT_GUARD,] }] },\n        { type: Router, decorators: [{ type: Optional }] }\n    ]; };\n    return RouterModule;\n}());\nexport { RouterModule };\n/**\n * @param {?} router\n * @param {?} viewportScroller\n * @param {?} config\n * @return {?}\n */\nexport function createRouterScroller(router, viewportScroller, config) {\n    if (config.scrollOffset) {\n        viewportScroller.setOffset(config.scrollOffset);\n    }\n    return new RouterScroller(router, viewportScroller, config);\n}\n/**\n * @param {?} platformLocationStrategy\n * @param {?} baseHref\n * @param {?=} options\n * @return {?}\n */\nexport function provideLocationStrategy(platformLocationStrategy, baseHref, options) {\n    if (options === void 0) { options = {}; }\n    return options.useHash ? new HashLocationStrategy(platformLocationStrategy, baseHref) :\n        new PathLocationStrategy(platformLocationStrategy, baseHref);\n}\n/**\n * @param {?} router\n * @return {?}\n */\nexport function provideForRootGuard(router) {\n    if (router) {\n        throw new Error(\"RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.\");\n    }\n    return 'guarded';\n}\n/**\n * \\@description\n *\n * Registers routes.\n *\n * ### Example\n *\n * ```\n * \\@NgModule({\n *   imports: [RouterModule.forChild(ROUTES)],\n *   providers: [provideRoutes(EXTRA_ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n *\n * @param {?} routes\n * @return {?}\n */\nexport function provideRoutes(routes) {\n    return [\n        { provide: ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes },\n        { provide: ROUTES, multi: true, useValue: routes },\n    ];\n}\n/** @typedef {?} */\nvar InitialNavigation;\nexport { InitialNavigation };\n/**\n * \\@description\n *\n * Represents options to configure the router.\n *\n *\n * @record\n */\nexport function ExtraOptions() { }\n/**\n * Makes the router log all its internal events to the console.\n * @type {?|undefined}\n */\nExtraOptions.prototype.enableTracing;\n/**\n * Enables the location strategy that uses the URL fragment instead of the history API.\n * @type {?|undefined}\n */\nExtraOptions.prototype.useHash;\n/**\n * Disables the initial navigation.\n * @type {?|undefined}\n */\nExtraOptions.prototype.initialNavigation;\n/**\n * A custom error handler.\n * @type {?|undefined}\n */\nExtraOptions.prototype.errorHandler;\n/**\n * Configures a preloading strategy. See `PreloadAllModules`.\n * @type {?|undefined}\n */\nExtraOptions.prototype.preloadingStrategy;\n/**\n * Define what the router should do if it receives a navigation request to the current URL.\n * By default, the router will ignore this navigation. However, this prevents features such\n * as a \"refresh\" button. Use this option to configure the behavior when navigating to the\n * current URL. Default is 'ignore'.\n * @type {?|undefined}\n */\nExtraOptions.prototype.onSameUrlNavigation;\n/**\n * Configures if the scroll position needs to be restored when navigating back.\n *\n * * 'disabled'--does nothing (default).\n * * 'top'--set the scroll position to 0,0..\n * * 'enabled'--set the scroll position to the stored position. This option will be the default in\n * the future.\n *\n * When enabled, the router stores and restores scroll positions during navigation.\n * When navigating forward, the scroll position will be set to [0, 0], or to the anchor\n * if one is provided.\n *\n * You can implement custom scroll restoration behavior as follows.\n * ```typescript\n * class AppModule {\n *  constructor(router: Router, viewportScroller: ViewportScroller, store: Store<AppState>) {\n *    router.events.pipe(filter(e => e instanceof Scroll), switchMap(e => {\n *      return store.pipe(first(), timeout(200), map(() => e));\n *    }).subscribe(e => {\n *      if (e.position) {\n *        viewportScroller.scrollToPosition(e.position);\n *      } else if (e.anchor) {\n *        viewportScroller.scrollToAnchor(e.anchor);\n *      } else {\n *        viewportScroller.scrollToPosition([0, 0]);\n *      }\n *    });\n *  }\n * }\n * ```\n *\n * You can also implement component-specific scrolling like this:\n *\n * ```typescript\n * class ListComponent {\n *   list: any[];\n *   constructor(router: Router, viewportScroller: ViewportScroller, fetcher: ListFetcher) {\n *     const scrollEvents = router.events.filter(e => e instanceof Scroll);\n *     listFetcher.fetch().pipe(withLatestFrom(scrollEvents)).subscribe(([list, e]) => {\n *       this.list = list;\n *       if (e.position) {\n *         viewportScroller.scrollToPosition(e.position);\n *       } else {\n *         viewportScroller.scrollToPosition([0, 0]);\n *       }\n *     });\n *   }\n * }\n * @type {?|undefined}\n */\nExtraOptions.prototype.scrollPositionRestoration;\n/**\n * Configures if the router should scroll to the element when the url has a fragment.\n *\n * * 'disabled'--does nothing (default).\n * * 'enabled'--scrolls to the element. This option will be the default in the future.\n *\n * Anchor scrolling does not happen on 'popstate'. Instead, we restore the position\n * that we stored or scroll to the top.\n * @type {?|undefined}\n */\nExtraOptions.prototype.anchorScrolling;\n/**\n * Configures the scroll offset the router will use when scrolling to an element.\n *\n * When given a tuple with two numbers, the router will always use the numbers.\n * When given a function, the router will invoke the function every time it restores scroll\n * position.\n * @type {?|undefined}\n */\nExtraOptions.prototype.scrollOffset;\n/**\n * Defines how the router merges params, data and resolved data from parent to child\n * routes. Available options are:\n *\n * - `'emptyOnly'`, the default, only inherits parent params for path-less or component-less\n *   routes.\n * - `'always'`, enables unconditional inheritance of parent params.\n * @type {?|undefined}\n */\nExtraOptions.prototype.paramsInheritanceStrategy;\n/**\n * A custom malformed uri error handler function. This handler is invoked when encodedURI contains\n * invalid character sequences. The default implementation is to redirect to the root url dropping\n * any path or param info. This function passes three parameters:\n *\n * - `'URIError'` - Error thrown when parsing a bad URL\n * - `'UrlSerializer'` - UrlSerializer that’s configured with the router.\n * - `'url'` -  The malformed URL that caused the URIError\n *\n * @type {?|undefined}\n */\nExtraOptions.prototype.malformedUriErrorHandler;\n/**\n * Defines when the router updates the browser URL. The default behavior is to update after\n * successful navigation. However, some applications may prefer a mode where the URL gets\n * updated at the beginning of navigation. The most common use case would be updating the\n * URL early so if navigation fails, you can show an error message with the URL that failed.\n * Available options are:\n *\n * - `'deferred'`, the default, updates the browser URL after navigation has finished.\n * - `'eager'`, updates browser URL at the beginning of navigation.\n * @type {?|undefined}\n */\nExtraOptions.prototype.urlUpdateStrategy;\n/**\n * Enables a bug fix that corrects relative link resolution in components with empty paths.\n * Example:\n *\n * ```\n * const routes = [\n *   {\n *     path: '',\n *     component: ContainerComponent,\n *     children: [\n *       { path: 'a', component: AComponent },\n *       { path: 'b', component: BComponent },\n *     ]\n *   }\n * ];\n * ```\n *\n * From the `ContainerComponent`, this will not work:\n *\n * `<a [routerLink]=\"['./a']\">Link to A</a>`\n *\n * However, this will work:\n *\n * `<a [routerLink]=\"['../a']\">Link to A</a>`\n *\n * In other words, you're required to use `../` rather than `./`. The current default in v6\n * is `legacy`, and this option will be removed in v7 to default to the corrected behavior.\n * @type {?|undefined}\n */\nExtraOptions.prototype.relativeLinkResolution;\n/**\n * @param {?} ref\n * @param {?} urlSerializer\n * @param {?} contexts\n * @param {?} location\n * @param {?} injector\n * @param {?} loader\n * @param {?} compiler\n * @param {?} config\n * @param {?=} opts\n * @param {?=} urlHandlingStrategy\n * @param {?=} routeReuseStrategy\n * @return {?}\n */\nexport function setupRouter(ref, urlSerializer, contexts, location, injector, loader, compiler, config, opts, urlHandlingStrategy, routeReuseStrategy) {\n    if (opts === void 0) { opts = {}; }\n    /** @type {?} */\n    var router = new Router(null, urlSerializer, contexts, location, injector, loader, compiler, flatten(config));\n    if (urlHandlingStrategy) {\n        router.urlHandlingStrategy = urlHandlingStrategy;\n    }\n    if (routeReuseStrategy) {\n        router.routeReuseStrategy = routeReuseStrategy;\n    }\n    if (opts.errorHandler) {\n        router.errorHandler = opts.errorHandler;\n    }\n    if (opts.malformedUriErrorHandler) {\n        router.malformedUriErrorHandler = opts.malformedUriErrorHandler;\n    }\n    if (opts.enableTracing) {\n        /** @type {?} */\n        var dom_1 = getDOM();\n        router.events.subscribe(function (e) {\n            dom_1.logGroup(\"Router Event: \" + ((/** @type {?} */ (e.constructor))).name);\n            dom_1.log(e.toString());\n            dom_1.log(e);\n            dom_1.logGroupEnd();\n        });\n    }\n    if (opts.onSameUrlNavigation) {\n        router.onSameUrlNavigation = opts.onSameUrlNavigation;\n    }\n    if (opts.paramsInheritanceStrategy) {\n        router.paramsInheritanceStrategy = opts.paramsInheritanceStrategy;\n    }\n    if (opts.urlUpdateStrategy) {\n        router.urlUpdateStrategy = opts.urlUpdateStrategy;\n    }\n    if (opts.relativeLinkResolution) {\n        router.relativeLinkResolution = opts.relativeLinkResolution;\n    }\n    return router;\n}\n/**\n * @param {?} router\n * @return {?}\n */\nexport function rootRoute(router) {\n    return router.routerState.root;\n}\n/**\n * To initialize the router properly we need to do in two steps:\n *\n * We need to start the navigation in a APP_INITIALIZER to block the bootstrap if\n * a resolver or a guards executes asynchronously. Second, we need to actually run\n * activation in a BOOTSTRAP_LISTENER. We utilize the afterPreactivation\n * hook provided by the router to do that.\n *\n * The router navigation starts, reaches the point when preactivation is done, and then\n * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.\n */\nvar RouterInitializer = /** @class */ (function () {\n    function RouterInitializer(injector) {\n        this.injector = injector;\n        this.initNavigation = false;\n        this.resultOfPreactivationDone = new Subject();\n    }\n    /**\n     * @return {?}\n     */\n    RouterInitializer.prototype.appInitializer = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        /** @type {?} */\n        var p = this.injector.get(LOCATION_INITIALIZED, Promise.resolve(null));\n        return p.then(function () {\n            /** @type {?} */\n            var resolve = /** @type {?} */ ((null));\n            /** @type {?} */\n            var res = new Promise(function (r) { return resolve = r; });\n            /** @type {?} */\n            var router = _this.injector.get(Router);\n            /** @type {?} */\n            var opts = _this.injector.get(ROUTER_CONFIGURATION);\n            if (_this.isLegacyDisabled(opts) || _this.isLegacyEnabled(opts)) {\n                resolve(true);\n            }\n            else if (opts.initialNavigation === 'disabled') {\n                router.setUpLocationChangeListener();\n                resolve(true);\n            }\n            else if (opts.initialNavigation === 'enabled') {\n                router.hooks.afterPreactivation = function () {\n                    // only the initial navigation should be delayed\n                    if (!_this.initNavigation) {\n                        _this.initNavigation = true;\n                        resolve(true);\n                        return _this.resultOfPreactivationDone;\n                        // subsequent navigations should not be delayed\n                    }\n                    else {\n                        return /** @type {?} */ (of(null));\n                    }\n                };\n                router.initialNavigation();\n            }\n            else {\n                throw new Error(\"Invalid initialNavigation options: '\" + opts.initialNavigation + \"'\");\n            }\n            return res;\n        });\n    };\n    /**\n     * @param {?} bootstrappedComponentRef\n     * @return {?}\n     */\n    RouterInitializer.prototype.bootstrapListener = /**\n     * @param {?} bootstrappedComponentRef\n     * @return {?}\n     */\n    function (bootstrappedComponentRef) {\n        /** @type {?} */\n        var opts = this.injector.get(ROUTER_CONFIGURATION);\n        /** @type {?} */\n        var preloader = this.injector.get(RouterPreloader);\n        /** @type {?} */\n        var routerScroller = this.injector.get(RouterScroller);\n        /** @type {?} */\n        var router = this.injector.get(Router);\n        /** @type {?} */\n        var ref = this.injector.get(ApplicationRef);\n        if (bootstrappedComponentRef !== ref.components[0]) {\n            return;\n        }\n        if (this.isLegacyEnabled(opts)) {\n            router.initialNavigation();\n        }\n        else if (this.isLegacyDisabled(opts)) {\n            router.setUpLocationChangeListener();\n        }\n        preloader.setUpPreloading();\n        routerScroller.init();\n        router.resetRootComponentType(ref.componentTypes[0]);\n        this.resultOfPreactivationDone.next(/** @type {?} */ ((null)));\n        this.resultOfPreactivationDone.complete();\n    };\n    /**\n     * @param {?} opts\n     * @return {?}\n     */\n    RouterInitializer.prototype.isLegacyEnabled = /**\n     * @param {?} opts\n     * @return {?}\n     */\n    function (opts) {\n        return opts.initialNavigation === 'legacy_enabled' || opts.initialNavigation === true ||\n            opts.initialNavigation === undefined;\n    };\n    /**\n     * @param {?} opts\n     * @return {?}\n     */\n    RouterInitializer.prototype.isLegacyDisabled = /**\n     * @param {?} opts\n     * @return {?}\n     */\n    function (opts) {\n        return opts.initialNavigation === 'legacy_disabled' || opts.initialNavigation === false;\n    };\n    RouterInitializer.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    RouterInitializer.ctorParameters = function () { return [\n        { type: Injector }\n    ]; };\n    return RouterInitializer;\n}());\nexport { RouterInitializer };\nif (false) {\n    /** @type {?} */\n    RouterInitializer.prototype.initNavigation;\n    /** @type {?} */\n    RouterInitializer.prototype.resultOfPreactivationDone;\n    /** @type {?} */\n    RouterInitializer.prototype.injector;\n}\n/**\n * @param {?} r\n * @return {?}\n */\nexport function getAppInitializer(r) {\n    return r.appInitializer.bind(r);\n}\n/**\n * @param {?} r\n * @return {?}\n */\nexport function getBootstrapListener(r) {\n    return r.bootstrapListener.bind(r);\n}\n/** *\n * A token for the router initializer that will be called after the app is bootstrapped.\n *\n * \\@experimental\n  @type {?} */\nexport var ROUTER_INITIALIZER = new InjectionToken('Router Initializer');\n/**\n * @return {?}\n */\nexport function provideRouterInitializer() {\n    return [\n        RouterInitializer,\n        {\n            provide: APP_INITIALIZER,\n            multi: true,\n            useFactory: getAppInitializer,\n            deps: [RouterInitializer]\n        },\n        { provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener, deps: [RouterInitializer] },\n        { provide: APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER },\n    ];\n}\n//# sourceMappingURL=router_module.js.map"]}