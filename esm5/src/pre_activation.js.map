{"version":3,"file":"pre_activation.js","sourceRoot":"","sources":["../../../../../packages/router/src/pre_activation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '@angular/core';\nimport {Observable, from, of } from 'rxjs';\nimport {concatMap, every, first, last, map, mergeMap, reduce} from 'rxjs/operators';\n\nimport {LoadedRouterConfig, ResolveData, RunGuardsAndResolvers} from './config';\nimport {ActivationStart, ChildActivationStart, Event} from './events';\nimport {ChildrenOutletContexts, OutletContext} from './router_outlet_context';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot, equalParamsAndUrlSegments, inheritedParamsDataResolve} from './router_state';\nimport {andObservables, forEach, shallowEqual, wrapIntoObservable} from './utils/collection';\nimport {TreeNode, nodeChildrenAsMap} from './utils/tree';\n\nclass CanActivate {\n  readonly route: ActivatedRouteSnapshot;\n  constructor(public path: ActivatedRouteSnapshot[]) {\n    this.route = this.path[this.path.length - 1];\n  }\n}\n\nclass CanDeactivate {\n  constructor(public component: Object|null, public route: ActivatedRouteSnapshot) {}\n}\n\n/**\n * This class bundles the actions involved in preactivation of a route.\n */\nexport class PreActivation {\n  private canActivateChecks: CanActivate[] = [];\n  private canDeactivateChecks: CanDeactivate[] = [];\n\n  constructor(\n      private future: RouterStateSnapshot, private curr: RouterStateSnapshot,\n      private moduleInjector: Injector, private forwardEvent?: (evt: Event) => void) {}\n\n  initialize(parentContexts: ChildrenOutletContexts): void {\n    const futureRoot = this.future._root;\n    const currRoot = this.curr ? this.curr._root : null;\n    this.setupChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n  }\n\n  checkGuards(): Observable<boolean> {\n    if (!this.isDeactivating() && !this.isActivating()) {\n      return of (true);\n    }\n    const canDeactivate$ = this.runCanDeactivateChecks();\n    return canDeactivate$.pipe(mergeMap(\n        (canDeactivate: boolean) => canDeactivate ? this.runCanActivateChecks() : of (false)));\n  }\n\n  resolveData(paramsInheritanceStrategy: 'emptyOnly'|'always'): Observable<any> {\n    if (!this.isActivating()) return of (null);\n    return from(this.canActivateChecks)\n        .pipe(\n            concatMap(\n                (check: CanActivate) => this.runResolve(check.route, paramsInheritanceStrategy)),\n            reduce((_: any, __: any) => _));\n  }\n\n  isDeactivating(): boolean { return this.canDeactivateChecks.length !== 0; }\n\n  isActivating(): boolean { return this.canActivateChecks.length !== 0; }\n\n\n  /**\n   * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n   * proper state to run `checkGuards()` method.\n   */\n  private setupChildRouteGuards(\n      futureNode: TreeNode<ActivatedRouteSnapshot>, currNode: TreeNode<ActivatedRouteSnapshot>|null,\n      contexts: ChildrenOutletContexts|null, futurePath: ActivatedRouteSnapshot[]): void {\n    const prevChildren = nodeChildrenAsMap(currNode);\n\n    // Process the children of the future route\n    futureNode.children.forEach(c => {\n      this.setupRouteGuards(\n          c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]));\n      delete prevChildren[c.value.outlet];\n    });\n\n    // Process any children left from the current route (not active for the future route)\n    forEach(\n        prevChildren, (v: TreeNode<ActivatedRouteSnapshot>, k: string) =>\n                          this.deactivateRouteAndItsChildren(v, contexts !.getContext(k)));\n  }\n\n  /**\n   * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n   * proper state to run `checkGuards()` method.\n   */\n  private setupRouteGuards(\n      futureNode: TreeNode<ActivatedRouteSnapshot>, currNode: TreeNode<ActivatedRouteSnapshot>,\n      parentContexts: ChildrenOutletContexts|null, futurePath: ActivatedRouteSnapshot[]): void {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n    const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\n\n    // reusing the node\n    if (curr && future.routeConfig === curr.routeConfig) {\n      const shouldRunGuardsAndResolvers = this.shouldRunGuardsAndResolvers(\n          curr, future, future.routeConfig !.runGuardsAndResolvers);\n      if (shouldRunGuardsAndResolvers) {\n        this.canActivateChecks.push(new CanActivate(futurePath));\n      } else {\n        // we need to set the data\n        future.data = curr.data;\n        future._resolvedData = curr._resolvedData;\n      }\n\n      // If we have a component, we need to go through an outlet.\n      if (future.component) {\n        this.setupChildRouteGuards(\n            futureNode, currNode, context ? context.children : null, futurePath);\n\n        // if we have a componentless route, we recurse but keep the same outlet map.\n      } else {\n        this.setupChildRouteGuards(futureNode, currNode, parentContexts, futurePath);\n      }\n\n      if (shouldRunGuardsAndResolvers) {\n        const outlet = context !.outlet !;\n        this.canDeactivateChecks.push(new CanDeactivate(outlet.component, curr));\n      }\n    } else {\n      if (curr) {\n        this.deactivateRouteAndItsChildren(currNode, context);\n      }\n\n      this.canActivateChecks.push(new CanActivate(futurePath));\n      // If we have a component, we need to go through an outlet.\n      if (future.component) {\n        this.setupChildRouteGuards(futureNode, null, context ? context.children : null, futurePath);\n\n        // if we have a componentless route, we recurse but keep the same outlet map.\n      } else {\n        this.setupChildRouteGuards(futureNode, null, parentContexts, futurePath);\n      }\n    }\n  }\n\n  private shouldRunGuardsAndResolvers(\n      curr: ActivatedRouteSnapshot, future: ActivatedRouteSnapshot,\n      mode: RunGuardsAndResolvers|undefined): boolean {\n    switch (mode) {\n      case 'always':\n        return true;\n\n      case 'paramsOrQueryParamsChange':\n        return !equalParamsAndUrlSegments(curr, future) ||\n            !shallowEqual(curr.queryParams, future.queryParams);\n\n      case 'paramsChange':\n      default:\n        return !equalParamsAndUrlSegments(curr, future);\n    }\n  }\n\n  private deactivateRouteAndItsChildren(\n      route: TreeNode<ActivatedRouteSnapshot>, context: OutletContext|null): void {\n    const children = nodeChildrenAsMap(route);\n    const r = route.value;\n\n    forEach(children, (node: TreeNode<ActivatedRouteSnapshot>, childName: string) => {\n      if (!r.component) {\n        this.deactivateRouteAndItsChildren(node, context);\n      } else if (context) {\n        this.deactivateRouteAndItsChildren(node, context.children.getContext(childName));\n      } else {\n        this.deactivateRouteAndItsChildren(node, null);\n      }\n    });\n\n    if (!r.component) {\n      this.canDeactivateChecks.push(new CanDeactivate(null, r));\n    } else if (context && context.outlet && context.outlet.isActivated) {\n      this.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n    } else {\n      this.canDeactivateChecks.push(new CanDeactivate(null, r));\n    }\n  }\n\n  private runCanDeactivateChecks(): Observable<boolean> {\n    return from(this.canDeactivateChecks)\n        .pipe(\n            mergeMap((check: CanDeactivate) => this.runCanDeactivate(check.component, check.route)),\n            every((result: boolean) => result === true));\n  }\n\n  private runCanActivateChecks(): Observable<boolean> {\n    return from(this.canActivateChecks)\n        .pipe(\n            concatMap((check: CanActivate) => andObservables(from([\n                        this.fireChildActivationStart(check.route.parent),\n                        this.fireActivationStart(check.route), this.runCanActivateChild(check.path),\n                        this.runCanActivate(check.route)\n                      ]))),\n            every((result: boolean) => result === true));\n    // this.fireChildActivationStart(check.path),\n  }\n\n  /**\n   * This should fire off `ActivationStart` events for each route being activated at this\n   * level.\n   * In other words, if you're activating `a` and `b` below, `path` will contain the\n   * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n   * return\n   * `true` so checks continue to run.\n   */\n  private fireActivationStart(snapshot: ActivatedRouteSnapshot|null): Observable<boolean> {\n    if (snapshot !== null && this.forwardEvent) {\n      this.forwardEvent(new ActivationStart(snapshot));\n    }\n    return of (true);\n  }\n\n  /**\n   * This should fire off `ChildActivationStart` events for each route being activated at this\n   * level.\n   * In other words, if you're activating `a` and `b` below, `path` will contain the\n   * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n   * return\n   * `true` so checks continue to run.\n   */\n  private fireChildActivationStart(snapshot: ActivatedRouteSnapshot|null): Observable<boolean> {\n    if (snapshot !== null && this.forwardEvent) {\n      this.forwardEvent(new ChildActivationStart(snapshot));\n    }\n    return of (true);\n  }\n\n  private runCanActivate(future: ActivatedRouteSnapshot): Observable<boolean> {\n    const canActivate = future.routeConfig ? future.routeConfig.canActivate : null;\n    if (!canActivate || canActivate.length === 0) return of (true);\n    const obs = from(canActivate).pipe(map((c: any) => {\n      const guard = this.getToken(c, future);\n      let observable: Observable<boolean>;\n      if (guard.canActivate) {\n        observable = wrapIntoObservable(guard.canActivate(future, this.future));\n      } else {\n        observable = wrapIntoObservable(guard(future, this.future));\n      }\n      return observable.pipe(first());\n    }));\n    return andObservables(obs);\n  }\n\n  private runCanActivateChild(path: ActivatedRouteSnapshot[]): Observable<boolean> {\n    const future = path[path.length - 1];\n\n    const canActivateChildGuards = path.slice(0, path.length - 1)\n                                       .reverse()\n                                       .map(p => this.extractCanActivateChild(p))\n                                       .filter(_ => _ !== null);\n\n    return andObservables(from(canActivateChildGuards).pipe(map((d: any) => {\n      const obs = from(d.guards).pipe(map((c: any) => {\n        const guard = this.getToken(c, d.node);\n        let observable: Observable<boolean>;\n        if (guard.canActivateChild) {\n          observable = wrapIntoObservable(guard.canActivateChild(future, this.future));\n        } else {\n          observable = wrapIntoObservable(guard(future, this.future));\n        }\n        return observable.pipe(first());\n      }));\n      return andObservables(obs);\n    })));\n  }\n\n  private extractCanActivateChild(p: ActivatedRouteSnapshot):\n      {node: ActivatedRouteSnapshot, guards: any[]}|null {\n    const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n    if (!canActivateChild || canActivateChild.length === 0) return null;\n    return {node: p, guards: canActivateChild};\n  }\n\n  private runCanDeactivate(component: Object|null, curr: ActivatedRouteSnapshot):\n      Observable<boolean> {\n    const canDeactivate = curr && curr.routeConfig ? curr.routeConfig.canDeactivate : null;\n    if (!canDeactivate || canDeactivate.length === 0) return of (true);\n    const canDeactivate$ = from(canDeactivate).pipe(mergeMap((c: any) => {\n      const guard = this.getToken(c, curr);\n      let observable: Observable<boolean>;\n      if (guard.canDeactivate) {\n        observable =\n            wrapIntoObservable(guard.canDeactivate(component, curr, this.curr, this.future));\n      } else {\n        observable = wrapIntoObservable(guard(component, curr, this.curr, this.future));\n      }\n      return observable.pipe(first());\n    }));\n    return canDeactivate$.pipe(every((result: any) => result === true));\n  }\n\n  private runResolve(\n      future: ActivatedRouteSnapshot,\n      paramsInheritanceStrategy: 'emptyOnly'|'always'): Observable<any> {\n    const resolve = future._resolve;\n    return this.resolveNode(resolve, future).pipe(map((resolvedData: any): any => {\n      future._resolvedData = resolvedData;\n      future.data = {...future.data,\n                     ...inheritedParamsDataResolve(future, paramsInheritanceStrategy).resolve};\n      return null;\n    }));\n  }\n\n  private resolveNode(resolve: ResolveData, future: ActivatedRouteSnapshot): Observable<any> {\n    const keys = Object.keys(resolve);\n    if (keys.length === 0) {\n      return of ({});\n    }\n    if (keys.length === 1) {\n      const key = keys[0];\n      return this.getResolver(resolve[key], future).pipe(map((value: any) => {\n        return {[key]: value};\n      }));\n    }\n    const data: {[k: string]: any} = {};\n    const runningResolvers$ = from(keys).pipe(mergeMap((key: string) => {\n      return this.getResolver(resolve[key], future).pipe(map((value: any) => {\n        data[key] = value;\n        return value;\n      }));\n    }));\n    return runningResolvers$.pipe(last(), map(() => data));\n  }\n\n  private getResolver(injectionToken: any, future: ActivatedRouteSnapshot): Observable<any> {\n    const resolver = this.getToken(injectionToken, future);\n    return resolver.resolve ? wrapIntoObservable(resolver.resolve(future, this.future)) :\n                              wrapIntoObservable(resolver(future, this.future));\n  }\n\n  private getToken(token: any, snapshot: ActivatedRouteSnapshot): any {\n    const config = closestLoadedConfig(snapshot);\n    const injector = config ? config.module.injector : this.moduleInjector;\n    return injector.get(token);\n  }\n}\n\n\nfunction closestLoadedConfig(snapshot: ActivatedRouteSnapshot): LoadedRouterConfig|null {\n  if (!snapshot) return null;\n\n  for (let s = snapshot.parent; s; s = s.parent) {\n    const route = s.routeConfig;\n    if (route && route._loadedConfig) return route._loadedConfig;\n  }\n\n  return null;\n}\n"]}